---
title: "Frame Timing"
output:
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{timing}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, include = FALSE}
library(diagram)

dig = function(title='',before=1,after = 1){
	xlim = c(0 - before,after)
	plot(NULL,xlim=xlim,ylim=c(0,2),axes='false',ylab='',xlab='')
	text(0-before,0.2,title,cex=1,adj=0)

	
	#arrows(xlim[1],0,xlim[2],0, xpd = TRUE, angle = 20)

	width = 0.02
	rect(0,0.5,1,1.5,border=NA,col='#cfb')
	#rect(-width*2,0.5,width*2,1.5)
	rect(-width,0.5,width,1.5,col='white')
	if (after > 0) for (i in 1:after) rect(i-width,0.5, i + width,1.5,col = 'black')
	if (before > 0) for (i in 1:before) rect(-i - width,0.5, -i + width,1.5,col = 'black')
	
	
	axis(1,at=c(-100,100),pos=0.5)
}


spot = function(x,white=FALSE){
	points(x,1,cex=ifelse(white,2,4/3),pch=ifelse(white,21,19),bg='white')
}

move = function(x1,x2,straight=FALSE){
	sig = sign(x1-x2)
	offset = ifelse(straight,sig * 0.08, 0)
	curvedarrow(c(x1,1),c(x2 + offset,1),arr.pos = ifelse(straight,1,0.9),endhead=TRUE,arr.type='triangle',curve=ifelse(straight,0,sig),xpd = TRUE,arr.length=0.15,arr.width=0.15)
}


#E
#par(mfrow=c(4,1),mar=c(0,0,0,0))
#dig('',0,0); spot(0.5); move(0.5,0.25,1); spot(0.25,1)
#dig('',0,0); spot(0.25); move(0.25,-0.5,1); spot(-0.5,1)
#dig('',0,0); spot(-0.5); move(-0.5,0.5); spot(0.5,1)




animate = function(titles,before,after,...){ #make the first point >100 to skip the first draw
	l = ...length()
	x = ..1

	panels = length(titles)
	par(mfrow=c(panels,1))
	
	labl = paste('1. ',titles[1],sep='')
	if (titles[1] == 'omit') {
		labl = titles[2]
		panels = panels - 1
		
		
		par(mfrow=c(panels,1))
	}
	else {dig(labl,before,after); spot(x,1)}
	
	if (l > 1) for (i in 1:(l-1)){
		newx = ...elt(i+1)
		labl = paste(i+1,'. ',titles[i+1],sep='')
		if (titles[1] == 'omit') labl = titles[i+1]
		dig(labl,before,after)
		for (p in newx){
			if (p!=x){
				spot(x)
				move(x,p,ifelse(p < x,TRUE,FALSE))
			}
			x = p
		}
		spot(x,1)
	}
}


#E
#animate('',0,0,0.5,0.25,-0.5,0.5)



#we'll need to define the plot sizes for these in the quarto page

#main
#animate(c('begin','sleep to the start of next frame','update RAM (advances 1 frame)','draw (takes a little time)','caught up'),0.5,1,0.2,-0.2,c(0.8,0.5),0.2,0.2)

#behind
#animate(c('begin','update','update','draw','caught up'),1,1,-0.8,c(0.2,-0.1),c(0.8,0.5),0.2,0.2)

#far behind
#animate(c('begin','update until ahead','draw','caught up'),4,1,-3.6,-c(2.6,2.9,1.9,2.2,1.2,1.5,0.5,0.8,-0.2,0.1,-0.9,-0.6),0.2,0.2)

#frameskipping
#animate(c('begin','update','draw (longer than a frame)','update twice','draw','etc. (two frames per draw)'),1.5,1,-0.6,c(0.4,0.1),-1.2,c(-0.2,-0.5,0.5,0.2),-1.2,c(-0.2,-0.5,0.5,0.2))



```

This article describes the intricacies of how the game runs (drawing an updating) at the desired framerate. This information is interesting for understanding the package at a deeper level but isn't important to know for for playing or making games with the package.

I'll give warning--- timing is particularly hard to wrap one's head around (it certainly took me a while!). I think I've come up with a good visual representation but it's still quite abstract.

## 1. Motivation

One of the big questions when making a gaming device is "How will I get the frames to happen on time, at the right speed?" Gaming consoles in the past had to overcome significant challenges to achieve this, but modern computing systems have some conveniences that make it much easier.

`rcade` uses a very simple and robust timing system to ensure that the game runs in realtime at the correct speed, by taking advantage of `base::Sys.time()`'s high precision.

### 1.1. Goal

But first: what do we want to do on each frame? What even *is* a frame?

Every `1/framerate` seconds, or 1/60th of a second for a 60fps (frames per second) game, we want to tick the game (iterate its physics, game logic, etc. for one timestep), and then draw the new game state.

A **"frame"** can refer to a lot of things here, but I try to use it precisely: 

* I use "frame" to mean "the window of time at which we want to draw a specific gamestate" or said drawing;

* And a "tick" is the specific gamestate, i.e. the RAM after updating (ticking) a certain amount of times.

Drawing a frame should ONLY happen if we're within the 1/60th window for it; this ensures that the game always looks like it runs at the same speed even if the drawing is choppy. If we run out of time to draw on a frame, we can skip the drawing step, but we want to minimize this.

Meanwhile, ticking doesn't actually have to happen at a specific time as long as it lines up with the drawing. All we care about is that the game is *drawn* at the correct time, and that it's on the right tick for when it's drawn. Because ticking the game is usually very quick, we can just tick a bunch to catch up if it ever falls behind the current drawing window.

## 2. Timing Diagram

We'll use this diagram to conceptualize the timing system. It's a little weird, but it does a good job of representing the way the timing system works.

```{r fig.width=5, fig.height=2}
#| echo: false
par(mar=c(1,0,0,0))

dig('',2,2); spot(0.5); spot(0.2,1); move(0.5,0.25,TRUE)
text(0.5,0.4,'\ncurrent frame;\n"sweet spot"',cex=0.8,adj=0.5)
text(1.5,0.4,'next frame',cex=0.8,adj=0.5)
text(-0.5,0.4,'previous frame',cex=0.8,adj=0.5)
text(-1.5,0.4,'two frames prior',cex=0.8,adj=0.5)
axis(1,at=c(-2,-1,0,1,2),pos=0.5)
title(xlab='Frames ahead of time.sec()',line=0)

curvedarrow(c(0.5,1),c(0.8,1.7),segment = c(0.2,0.8), curve=0, arr.type='none',lwd=0.5)
text(0.8,1.7,'previous position',cex=0.8,adj=0)

curvedarrow(c(0.2,1),c(-0.3,1.7),segment = c(0.1,0.8), curve=0, arr.type='none',lwd=0.5)
text(-0.2,1.7,'current RAM position',cex=0.8,adj=1)
```

The vertical bars represent desired frames of the game--- when we *want* the game to advance and draw a frame. As such, they're spaced 1/60th of a second apart from each other (for a 60fps game).

The circle represents, roughly, where the RAM is time-wise relative to these frames[^1]. We want it to be "ahead" (to the right) of the current frame (white bar), but not too far ahead.

[^1]: Specifically, this is `RAM$time - time.sec()`.

```{r fig.width=5, fig.height=2}
#| echo: false
par(mar=c(0,0,0,0))
animate(c('omit','RAM is behind where it should be.'),3,1,-2.5,-2.5)
```

As time passes, if we don't update the RAM, it slowly drifts to the left until it's behind the current frame. To keep it ahead, we have to update it--- every update of the RAM moves it one frame ahead.

```{r fig.width=4, fig.height=3}
#| echo: false
par(mar=c(0,0,0,0))

animate(c('omit','The RAM moves backwards as time passes.','RAM is updated 3 times, advancing 3 frames.'),3,0.8,0.4,-2.8,c(-1.8,-0.8,0.2))
```

So the obvious thing to do is to just update it every time it falls behind the current frame, to get it back ahead. That's basically how the engine works!

```{r fig.width=3, fig.height=4}
#| echo: false
par(mar=c(0,0,0,0))
animate(c('begin','time passes','time passes; RAM is now behind current frame','RAM advances; back where it started'),0.8,1,0.5,0.25,-0.5,0.5)
```

## 3. Timing Logic

Now, we also want to draw the game, and to make it feel smooth, we only want to do this when the game is "at" the current frame--- ahead of the white bar. So the logic for timing the game is:

```         
1.  if within of the current frame, sleep (wait) until the game is just behind the current frame
2.  update the RAM (advance a frame)
3.  if within of the current frame, draw the RAM
4.  repeat
```

This mirrors the code found in `ram.update()`.  
Notably, this has the following behavior:

-   the game can never run ahead more than a frame
-   if the game is behind, it repeatedly updates as fast as possible until it's caught up

## 4. Examples:

The following diagrams demonstrate this behavior and the engine's response to various scenarios, based purely on the logic defined above.

Note that updating or drawing the RAM both take a little time, but the timing logic is robust to it. Even when drawing takes *more than a frame* (which can happen at higher game resolutions), the engine is able to deal with it and still draw on time as frequently as possible!

### 4.1 Standard Loop

This is what the game does most of the time when everything is working smoothly.

```{r fig.width=2, fig.height=4}
#| echo: false
par(mar=c(0,0,0,0))
animate(c('begin','sleep to the end of this frame','update RAM (advances 1 frame)','draw (takes a little time)','repeat'),0.5,1,0.2,-0.2,c(0.8,0.6),0.2,0.2)
```

### 4.2 Slightly Behind

When the RAM is a little behind for whatever reason, it quickly catches up.

```{r fig.width=2, fig.height=4}
#| echo: false
par(mar=c(0,0,0,0))
animate(c('begin (behind)','update (still behind)','update (now ahead)','caught up'),1,1,-0.8,c(0.2,-0.1),c(0.8,0.5),0.5)
```

### 4.3 Far Behind

When the RAM is far behind (e.g. right after a rollback; see `vignette("rollback")`), it updates as quickly as possible to catch up.

```{r fig.width=5, fig.height=3}
#| echo: false
par(mar=c(0,0,0,0))
animate(c('begin','update until ahead','caught up'),4,1,-3.6,-c(2.6,2.9,1.9,2.2,1.2,1.5,0.5,0.8,-0.2,0.1,-0.9,-0.6),0.6)
```

### 4.4 Frame Skipping

If drawing the RAM takes more than a frame, the engine organically skips drawing every other frame (or more) to keep running and drawing in realtime.

```{r fig.width=2, fig.height=4}
#| echo: false
par(mar=c(0,0,0,0))
animate(c('begin','update','draw (longer than a frame)','update twice','draw','etc. (two frames per draw)'),1.5,1,-0.6,c(0.4,0.1),-1.2,c(-0.2,-0.5,0.5,0.2),-1.2,c(-0.2,-0.5,0.5,0.2))
```

## 5. Notes

Records of salient timings can be found in `RAM$debug` (see `?ram.debug`) after running a game:

-   `RAM$debug$ahead` corresponds to the x position (in seconds) of the white circle in these diagrams at the end of every logic cycle.

-   `RAM$debug$time.draw` records the time it takes for just the draw step, `ram.draw()`. This can be helpful for identifying if drawing is the cause of frameskipping, as in the last example.

-   `RAM$debug$time.tick` records the time for just the tick step, `ram.tick()`. This is usually instant unless your game runs a physics system with lots of complex interactions or uses the likes of a chess engine.
