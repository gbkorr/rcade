---
title: "R^2^Studio"
output: 
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{r2studio}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

We have a graphics system. Why not render an R console?

This article describes the `R2Studio` ROM, which lets you run RStudio... in RStudio. Unlike `vignette("snake")`, the article does not use a walkthrough-based format, and instead just covers the various systems present in making the ROM work. You can always inspect the ROM object (`View(R2Studio)`) to take a closer look at its code.


# GO THROUGH SNAKE and organize the source code into nice chunks #----

## 1. Goals
I wanted this ROM to provide the full R console experience and have some basic plotting capabilities. The goals were as follows:

- accurately render an R console
- provide an R environment that can save its own variables
- have the ability to make a basic scatterplot
- let the R environment interact with the RAM, to allow you to change 'settings' like font

We don't need a smooth framerate for this--- one frame per second should be plenty.

## 2. UI
`R2Studio$draw_ui():`

The UI is inspired by RStudio and features a console and plotting window. The sprites are remade and drawn every frame in `R2Studio$draw_ui()`, allowing them to adapt to changes in the display resolution. All the function really does is make a few bordered boxes with a little text.

[image of just the ui w/ blank plot and console]

## 3. R Console
`R2Studio$evaluate():`

Running R code isn't very hard, since it's ultimately running in the main R instance. All we have to do is capture and evaluate whatever input the user gave, using `base::parse()` and `base::eval()`. In startup the RAM makes an environment (`RAM$environment`), and we just tell `eval()` to run the captured code in that environment.

The regular R console also prints the result of evaluations--- e.g.,
```
> 3 + 5
[1] 8
```

We can get this result using `utils::capture.output()`. Then we just add the little '>' to the expression string, and save both it and the result's string as entries in `RAM$objects$console$text`.

### 3.1 Multiline Expressions
There's also a little code to render multiline expressions properly, e.g.
```
> sample(
+     1:10,
+     2
+ )
[1]  1 10
```

Multiline inputs (made with Shift+Enter) get interpreted by rcade as multiple inputs from the same frame, so R^2^Studio pastes these back together before passing them as an expression string. Then newlines in the string are identified to figure out where to add that little '+' on subsequent lines.

### 3.2 Rendering the Console
`R2Studio$draw_console():`

With expressions and outputs saved in order in `RAM$objects$console$text`, rendering the console is as easy as stacking these into one string with `paste(...,sep='\n')` and drawing it at the top of the console area with `render.text()`. Only the most recent entries are used, and only enough to fit the vertical width of the display area.

I chose not to wrap lines because of the limited space--- if text wrapped, single lines would end up filling the whole console and I think it'd be harder to read overall.

## 4. Plotting
`R2Studio$draw_plot():`

Since this is more of a proof of concept, I don't need terribly advanced plotting functionality--- I just want to be able to make a nice little scatterplot.

The plot is drawn on a separate box dedicated to plotting which is drawn over the regular console. Its width can be changed with `use.size(plot.width=...)` (see section 5).

Drawing points on the plot is just a matter of doing a little math to scale them to the right spot based on the plot size and x/ylims, and then drawing the sprite of each point. There's also a little handling to interpret the likes of `plot(1:5)` and `plot(1:5,rep(1,5))` differently like R does.

The point sprites are made in `R2Studio$pch()`, which makes little geometric shapes at the desired `cex` size.

[image demo of pch sprites]

### 4.1 Hooking `plot()`
In order to recognize `plot()` calls, and have them not be interpreted as real `base::plot()` calls (which would be rendered in the actual RStudio window), `R2Studio$evaluate()` checks if the expression starts with `"plot("`. If it does, it replaces the start with `"R2Studio$plot(RAM,"`, so that gets evaluated instead; this calls `R2Studio$plot()`, which has all our custom plotting code.

Because I gave `RAM$environment` access to the RAM itself, code can edit the RAM; we can use this here to save the new plot info to `RAM$objects$plotwindow`, which `R2Studio$draw_plot()` uses to draw the plot. Access to the RAM also lets us change its 'settings', as shown in the next section:

### 5. Meta Functions
The approach to swapping out `plot()` for a custom function also lets us create our own new custom functions that only work in the R^2^Studio environment. 

I use this to provide some convenience functions that interact with the game itself to change the font, resize the display area, etc. All they do is edit `RAM$ROM` properties, and the game is rendered in such a way that respects live changes to these--- almost everything draws through `obj$draw()` rather than the default sprite system.


# ALSO PALETTE SWAPPING: stick this onto use.font

# what are these meta functions? list them all and have a small image demo (e.g. to compare fonts and sizes)



image of a couple different UI sizes

# 6. R^3^Studio
We can also... boot up the R^2^Studio ROM in this environment. rcade is actually functional in this state, but you have to influence and update it manually: by using `ram.input()` and `ram.tick()`. `ram.run()` won't work for several reasons, so games can only display individual frames rather than running in realtime.

[hello world image]

How cool is that! Rendering RStudio in a render of RStudio in RStudio.


