<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>High-Level Engine Structure • rcade</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="High-Level Engine Structure">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">rcade</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">1.0.0</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../articles/rcade.html">Get started</a></li>
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/engine.html">High-Level Engine Structure</a></li>
    <li><a class="dropdown-item" href="../articles/guide.html">Basic Package Usage</a></li>
    <li><a class="dropdown-item" href="../articles/inputs.html">Input Handling</a></li>
    <li><a class="dropdown-item" href="../articles/render.html">Drawing to Console</a></li>
    <li><a class="dropdown-item" href="../articles/rollback.html">Rollback in the rcade Engine</a></li>
    <li><a class="dropdown-item" href="../articles/snake.html">Snake Devlog</a></li>
    <li><a class="dropdown-item" href="../articles/timing.html">Frame Timing</a></li>
  </ul>
</li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>High-Level Engine Structure</h1>
            
      

      <div class="d-none name"><code>engine.Rmd</code></div>
    </div>

    
    
<p>This article describes how the package handles and runs games at a
high level.<br>
For a description of how the player interacts with the game, see
<code><a href="../articles/guide.html">vignette("guide")</a></code>.<br>
For a walkthrough of creating a game, see
<code><a href="../articles/snake.html">vignette("snake")</a></code>.</p>
<div class="section level2">
<h2 id="rom-and-ram">1. ROM and RAM<a class="anchor" aria-label="anchor" href="#rom-and-ram"></a>
</h2>
<p>To run a game, we’ll use two objects: the ROM and RAM.<a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content="&lt;p&gt;Named after the equivalent concepts in retro games!&lt;/p&gt;"><sup>1</sup></a></p>
<p>The ROM (<code><a href="../reference/rom.init.html">rom.init()</a></code>) contains everything static for the
game— code, images, and information about how to draw the game.</p>
<p>The RAM (<code><a href="../reference/ram.init.html">ram.init()</a></code>) stores everything dynamic— player
coordinates, game timer, current inputs— and is constantly updated as
the game is run.</p>
<p>This structure is particularly convenient for two reasons. For one,
because <strong>all game code</strong> is stored in one object (the
ROM), games are easy to handle and load— we just need to make the ROM
object and edit it, or load a premade one like
<code>SuperRrio</code>.</p>
<p>The other convenience is that, by storing all dynamic info in one
object (the RAM), we can easily <strong>copy that object</strong> to
create a savestate— a snapshot of the game at a given moment that can be
saved and loaded later. This allows the engine to be very robust, as any
issues (like an input not registering) can be rolled back (see
<code><a href="../articles/rollback.html">vignette("rollback")</a></code>) to an earlier savestate and rerun
correctly.</p>
</div>
<div class="section level2">
<h2 id="making-and-running-a-game">2. Making and Running a Game<a class="anchor" aria-label="anchor" href="#making-and-running-a-game"></a>
</h2>
<p>The basic usage of the engine is structured like this:</p>
<ol style="list-style-type: decimal">
<li>game dev creates and adds game code, art, etc. to ROM object</li>
<li>player uses ROM to initialize RAM object for playing</li>
<li>player runs the game using this RAM<a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content='&lt;p&gt;Steps 2 and 3 are usually combined and run together with
&lt;code&gt;&lt;a href="../reference/quickload.html"&gt;quickload()&lt;/a&gt;&lt;/code&gt;.&lt;/p&gt;'><sup>2</sup></a>
</li>
<li>player starts an additional R session to send inputs to the
game</li>
</ol>
<p>The two R sessions are referred to as the <strong>display
session</strong>, where most of the code happens and the game is drawn,
and the <strong>input session</strong>, where the player sends inputs to
the game.</p>
<p>In code, the four steps look like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a>  <span class="co">#1</span></span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>Game <span class="ot">=</span> <span class="fu">rom.init</span>({game stuff})</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a>Game<span class="sc">$</span>morestuff <span class="ot">=</span> {additional game stuff}</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a>  <span class="co">#2</span></span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a>RAM <span class="ot">=</span> <span class="fu">ram.init</span>(Game)</span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a>    </span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a>  <span class="co">#3</span></span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a>RAM <span class="ot">=</span> <span class="fu">ram.run</span>(Game)</span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" tabindex="-1"></a>  <span class="co">#4 (in separate session/window)</span></span>
<span id="cb1-12"><a href="#cb1-12" tabindex="-1"></a><span class="fu">inputs.listen</span>()</span></code></pre></div>
<p>The game then runs constantly and responds to any inputs by the
player in the input session.</p>
<p>From here, the player can <code>^C</code> in the display session to
interrupt (pause) the game and inspect the RAM object, continue the
game, or even edit the ROM.<a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content='&lt;p&gt;Note: since the ROM is loaded into the RAM, changes to
the ROM will have to pushed to the RAM with
&lt;code&gt;RAM$ROM = newrom&lt;/code&gt;. It’s almost always better to just restart
the game by rerunning &lt;code&gt;&lt;a href="../reference/ram.init.html"&gt;ram.init()&lt;/a&gt;&lt;/code&gt;.&lt;/p&gt;'><sup>3</sup></a></p>
</div>
<div class="section level2">
<h2 id="the-gameloop">3. The Gameloop<a class="anchor" aria-label="anchor" href="#the-gameloop"></a>
</h2>
<p>Once the RAM is run, it executes the <strong>gameloop</strong> over
and over. This is where all the code dedicated to running the engine,
drawing the game, running game logic, etc. is called.</p>
<p>The gameloop involves four distinct systems:</p>
<ul>
<li><p><strong>Game Code</strong>: Running the game.</p></li>
<li><p><strong>Inputs</strong>: Interfacing with the player.</p></li>
<li><p><strong>Timing</strong>: Executing the gameloop at the right
pace.</p></li>
<li><p><strong>Rendering</strong>: Drawing the game to the
console.</p></li>
</ul>
<p>Each system has a full article (linked in the sections below) either
describing or demonstrating the system.</p>
<div class="section level3">
<h3 id="game-code">3.1 Game Code<a class="anchor" aria-label="anchor" href="#game-code"></a>
</h3>
<p><code><a href="../articles/snake.html">vignette("snake")</a></code></p>
<p>Game code is run in <code>ROM$custom()</code> and is made by the game
dev. It reads and writes to RAM to do things like respond to player
inputs, move characters around, and trigger events like game end.</p>
</div>
<div class="section level3">
<h3 id="inputs">3.2 Inputs<a class="anchor" aria-label="anchor" href="#inputs"></a>
</h3>
<p><code><a href="../articles/inputs.html">vignette("inputs")</a></code></p>
<p>The Input system serves to let the player interact with the game live
as it runs. It consists of a <strong>listener</strong> to record player
inputs and code to interact with the listener, as well as code to turn
recorded inputs into something usable by the Game Code.</p>
<p>The documentation for <code>inputs.get()</code> has a good
description of the input pipeline, from the player pressing keyboard
keys to the input being interpreted by game code.</p>
</div>
<div class="section level3">
<h3 id="timing">3.3 Timing<a class="anchor" aria-label="anchor" href="#timing"></a>
</h3>
<p><code><a href="../articles/timing.html">vignette("timing")</a></code></p>
<p>The Timing system ensures that the game runs and draws at the correct
speed. This involves speeding up or slowing down when the game is ahead
or behind of where it “should” be (according to the desired speed,
determined by <code>ROM$framerate</code>), and deciding whether or not
to draw a given tick— for the game to look smooth, drawing must only
happen when the game is “caught up”.</p>
</div>
<div class="section level3">
<h3 id="rendering">3.4 Rendering<a class="anchor" aria-label="anchor" href="#rendering"></a>
</h3>
<p><code><a href="../articles/render.html">vignette("render")</a></code></p>
<p>The Rendering system consists of a host of functions dedicated to
rendering the current <strong>scene</strong>—the way objects are
organized onscreen on a given tick/gamestate—to the console, which is
where the game is displayed.</p>
<p>This involves:</p>
<ul>
<li><p>getting the right sprite (image) for each object and putting it
in the right place and layer in the scene
(<code><a href="../reference/render.sprite.html">render.sprite()</a></code>)</p></li>
<li><p>combining the whole scene into one object to be rendered
(<code><a href="../reference/render.scene.html">render.scene()</a></code>)</p></li>
<li><p>making this object printable to the console
(<code><a href="../reference/render.matrix.html">render.matrix()</a></code>)</p></li>
</ul>
</div>
</div>
<div class="section level2">
<h2 id="alternative-methods-of-interaction">4. Alternative Methods of Interaction<a class="anchor" aria-label="anchor" href="#alternative-methods-of-interaction"></a>
</h2>
<p>While the default way of interacting with the game is using
<code><a href="../reference/ram.run.html">ram.run()</a></code> and <code><a href="../reference/inputs.listen.html">inputs.listen()</a></code>, a couple other
options are available.</p>
<div class="section level3">
<h3 id="listener-frame-advance">4.1 Listener Frame Advance<a class="anchor" aria-label="anchor" href="#listener-frame-advance"></a>
</h3>
<p>The live game can be suspended at any time by inputting
<code>/pause</code> in the input session. Then:</p>
<ul>
<li><p>The player can input <code>/tick</code> to advance one tick
forward (and draw the scene again).</p></li>
<li><p>The player can type regular inputs, which will be processed by
the game the next time <code>/tick</code> is called (or the game is
resumed).</p></li>
<li><p>The player can resume live gameplay by inputting
<code>/resume</code>.</p></li>
</ul>
<p>This behavior is documented in <code><a href="../reference/inputs.command.html">?inputs.command</a></code>. I find
this method to be more convenient than that in the next section, since
staying in the input session allows for more fluid transition between
live and tick-by-tick gameplay.</p>
</div>
<div class="section level3">
<h3 id="manual-advance">4.2 Manual Advance<a class="anchor" aria-label="anchor" href="#manual-advance"></a>
</h3>
<p>Forgoing the need for the listener session, the game can also be
paused and manipulated directly in the display session. This gives the
user more control over altering the RAM that may be especially useful
for debugging.</p>
<p>This is done by pausing the game with <code>^C</code> (which ends the
<code>ram.run</code> process). The RAM object can then be manipulated
freely:</p>
<ul>
<li><p><code>RAM = ram.tick(RAM)</code> advances the game one
tick.</p></li>
<li><p><code>RAM = ram.input(RAM, [input])</code> adds an input to RAM
that will be processed on the next tick.</p></li>
<li><p><code>RAM = ram.run(RAM)</code> resumes the game (requiring the
input session again to interact)</p></li>
</ul>
<p>While paused, the RAM can also be easily saved and reloaded by
copying it, as in the following code:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a>savestate_1 <span class="ot">=</span> RAM</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>RAM <span class="ot">=</span> <span class="fu">ram.run</span>(RAM)</span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a><span class="co">#play the game a bit via the input session</span></span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a><span class="sc">^</span>C</span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a>RAM <span class="ot">=</span> savestate_1 <span class="co">#restore the savestate</span></span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a>RAM <span class="ot">=</span> <span class="fu">ram.run</span>(RAM) <span class="co">#the game is now back to where it was when savestate_1 was saved</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="gameloop-function-tree">5. Gameloop Function Tree<a class="anchor" aria-label="anchor" href="#gameloop-function-tree"></a>
</h2>
<p>The gameloop consists of the following nesting of functions in
order:</p>
<ul>
<li>
<p><code><a href="../reference/ram.run.html">ram.run()</a></code> once to start or resume the game</p>
<ul>
<li><p><strong>Timing</strong>:</p></li>
<li>
<p><code><a href="../reference/ram.update.html">ram.update()</a></code> every tick (see
<code><a href="../articles/timing.html">vignette("timing")</a></code>)</p>
<ul>
<li><p><strong>Inputs</strong>:</p></li>
<li>
<p><code>inputs.get()</code></p>
<ul>
<li><p><code><a href="../reference/inputs.listen.html">inputs.read()</a></code></p></li>
<li><p><code><a href="../reference/inputs.command.html">inputs.command()</a></code> if any commands are sent</p></li>
<li><p><code>inputs.rollback()</code> if any inputs were received
late</p></li>
</ul>
</li>
<li><p><code><a href="../reference/inputs.process.html">inputs.process()</a></code></p></li>
<li><p><strong>Game Code</strong>:</p></li>
<li>
<p><code><a href="../reference/ram.tick.html">ram.tick()</a></code></p>
<ul>
<li><code>RAM$ROM$custom()</code></li>
</ul>
</li>
<li><p><strong>Rendering</strong>:</p></li>
<li>
<p><code><a href="../reference/render.ram.html">render.ram()</a></code> if <code>RAM$time &gt;</code>
<code><a href="../reference/time.sec.html">time.sec()</a></code></p>
<ul>
<li>
<p><code><a href="../reference/render.object.html">render.object()</a></code> for every object in
<code>RAM$objects</code></p>
<ul>
<li><p><code><a href="../reference/render.animate.html">render.animate()</a></code> if the object’s sprite is
animated</p></li>
<li>
<p><code><a href="../reference/render.sprite.html">render.sprite()</a></code> or custom
<code>obj$draw()</code></p>
<ul>
<li><code><a href="../reference/render.overlay.html">render.overlay()</a></code></li>
</ul>
</li>
</ul>
</li>
<li>
<p><code><a href="../reference/render.scene.html">render.scene()</a></code></p>
<ul>
<li>
<code><a href="../reference/render.overlay.html">render.overlay()</a></code> for every layer in
<code>scene$layers</code>
</li>
</ul>
</li>
<li><p><code><a href="../reference/render.matrix.html">render.matrix()</a></code></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>This tree can also be found in the documentation in
<code><a href="../reference/ram.run.html">?ram.run</a></code>.</p>
</div>

  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Gabriel Broussard Korr.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.2.0.</p>
</div>

    </footer>
</div>





  </body>
</html>
