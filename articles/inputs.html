<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Input Handling • rcade</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Input Handling">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">rcade</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">1.0.0</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../articles/rcade.html">Get started</a></li>
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/engine.html">High-Level Engine Structure</a></li>
    <li><a class="dropdown-item" href="../articles/guide.html">Basic Package Usage</a></li>
    <li><a class="dropdown-item" href="../articles/inputs.html">Input Handling</a></li>
    <li><a class="dropdown-item" href="../articles/render.html">Drawing to Console</a></li>
    <li><a class="dropdown-item" href="../articles/rollback.html">Rollback in the rcade Engine</a></li>
    <li><a class="dropdown-item" href="../articles/snake.html">Snake Devlog</a></li>
    <li><a class="dropdown-item" href="../articles/timing.html">Frame Timing</a></li>
  </ul>
</li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Input Handling</h1>
            
      

      <div class="d-none name"><code>inputs.Rmd</code></div>
    </div>

    
    
<p>This article aims to explain the motivation behind how the inputs
system works, as well as giving an understanding of its structure; the
documentation for <code><a href="../reference/inputs.process.html">inputs.process()</a></code> has a more specific (and
concise) explanation of the input pipeline.</p>
<div class="section level3">
<h3 id="overview">1. Overview<a class="anchor" aria-label="anchor" href="#overview"></a>
</h3>
<p>The Input system has the tall task of communicating live with the
game process. Trouble is, R doesn’t make this easy!</p>
<p>R Games in the past were thwarted by the fact that R’s only native
method of taking user input, <code><a href="https://rdrr.io/r/base/readline.html" class="external-link">base::readline()</a></code>, fully
suspends the R process until an input is given<a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content="&lt;p&gt;So games typically used shiny or similar packages which
let them capture user events without suspending the process.&lt;/p&gt;"><sup>1</sup></a>. The natural way
around this, of course, is to just use two processes!</p>
<p>And that’s what the input system does. We use one Rstudio session to
run and draw the main game constantly, without interruption, and use a
second session to interact with the player. All this second session has
to do is relay inputs to the first.</p>
</div>
<div class="section level3">
<h3 id="recording-inputs">2. Recording Inputs<a class="anchor" aria-label="anchor" href="#recording-inputs"></a>
</h3>
<p>Getting input from a user isn’t very hard in R— looping
<code><a href="https://rdrr.io/r/base/readline.html" class="external-link">readline()</a></code> lets us capture the full text string input by
the user between every Enter press. We actually use
<code>readLines(n=1)</code> instead, which does the exact same thing but
doesn’t remove leading and trailing whitespace. This lets us use SPACE
(’ ’) as a valid key for actions.</p>
</div>
<div class="section level3">
<h3 id="transmitting-inputs">3. Transmitting Inputs<a class="anchor" aria-label="anchor" href="#transmitting-inputs"></a>
</h3>
<p>The listening session sends these inputs to the game session by
adding them to the end of a dataframe stored in a .csv file, using
<code>utils::write.table(append=TRUE)</code>. R can read and write to
.csvs quite quickly—–much faster than it can print text, for example–—so
we can have the game read the .csv file every tick to see if any new
inputs have been created.</p>
<p>But where should this file be located? Luckily, R provides a
dedicated folder for storing local data for a package:
<code><a href="https://rdrr.io/r/tools/userdir.html" class="external-link">tools::R_user_dir()</a></code>. Since the player can only type in one
window at a time, we’re not really going to have multiple input sessions
going on, so we can just reuse the same .csv file each time we play a
game; <code><a href="../reference/ram.init.html">ram.init()</a></code> wipes the file at the start of each
game.</p>
<p>Now, on every tick, the game reads the contents of that .csv file and
has to figure out what to do with them.</p>
</div>
<div class="section level3">
<h3 id="interpreting-inputs">4. Interpreting Inputs<a class="anchor" aria-label="anchor" href="#interpreting-inputs"></a>
</h3>
<p>Ultimately, we want an input to convey a certain set of keyboard keys
that should be interpreted as pressed on a certain tick. That’s what the
player is ‘expecting’ an input system to do.</p>
<p>The keys are easy—– we’re already storing a string of characters that
we can split up to see the individual keys the player pressed. But how
do we get from the exact <code><a href="../reference/time.sec.html">time.sec()</a></code> (absolute time in
seconds) of the input, which our listener records, to the tick the input
should happen on?</p>
<p>This can be accomplished in a few ways that all do basically the same
thing. For convenience, I settled on the approach of converting the
timestamp directly into a tick number—the tick the input should occur
on—before being interpreted by the game.</p>
<p>So the game reads the inputs from the .csv file, determines which
ones it hasn’t seen before, converts their timestamps to ticks, and
saves the new inputs to <code>RAM$inputs</code>. All this is done in
<code>inputs.get()</code>.</p>
</div>
<div class="section level3">
<h3 id="timestamp-to-frame-conversion">5. Timestamp-to-Frame Conversion<a class="anchor" aria-label="anchor" href="#timestamp-to-frame-conversion"></a>
</h3>
<p>How do we get from a timestamp to the tick it should occur on?</p>
<p>This is tied to how the game accomplishes frame Timing (see
<code><a href="../articles/timing.html">vignette("timing")</a></code>) in general. The timing system will sync
itself to have a tick occur every <code>1/framerate</code> seconds from
when it last resumed, so we can manually calculate what time corresponds
to what tick if we record the time the game resumed. The math for this
is in <code>?inputs.get</code>.</p>
<p>We also want to add a slight amount of <strong>input delay</strong>–—
pretending all inputs were made a little later than they really
were—because inputs aren’t transmitted and read instantly. If they were,
every input would be received slightly after it was made, and every
input would be late!<a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content="&lt;p&gt;Input delay is determined by
&lt;code&gt;ROM$input_delay&lt;/code&gt;, and is fine at 1/60th. Even at 0 input
delay, many inputs arrive on time because they’re snapped to the start
of the next tick (which is often after they arrive). This variable
becomes more useful online, where higher input delays can compensate for
slower connections—– reducing the frequency of rollbacks (late inputs)
at the cost of slightly less responsive controls. 1/10th of a second is
reasonable in those contexts, with higher values being passable but
sluggish.&lt;/p&gt;"><sup>2</sup></a></p>
</div>
<div class="section level3">
<h3 id="processing-inputs">6. Processing Inputs<a class="anchor" aria-label="anchor" href="#processing-inputs"></a>
</h3>
<p>This whole process leaves us with <code>RAM$inputs</code>, a
dataframe of input strings and the corresponding ticks they should occur
on.</p>
<p>Now the game can, on every tick, just look at which inputs correspond
to the current tick, and apply the input as such.</p>
<p>Inputs are applied by using each character of the input string to key
<code>ROM$keybinds</code>, which stores the <em>action</em> each
keypress should correspond to— this then updates
<code>RAM$actions</code>, which the game logic can read to see if, for
example, the player pressed the key for JUMP this frame. This process is
detailed in <code><a href="../reference/inputs.process.html">?inputs.process</a></code>.</p>
</div>
<div class="section level3">
<h3 id="late-inputs">7. Late Inputs<a class="anchor" aria-label="anchor" href="#late-inputs"></a>
</h3>
<p>What if, because of computer lag or online latency, the game receives
an input <em>after</em> it was supposed to happen? The game is designed
to be able to smoothly handle this scenario— something many engines
struggle with.</p>
<p>Because the RAM constantly backs itself up, we can just
<code><a href="../reference/ram.rollback.html">ram.rollback()</a></code> to a previous version and rerun the game.
RAM$inputs is <em>not</em> rolled back, so when the game reruns itself,
it’ll now have access to the inputs that it missed before!</p>
</div>

  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Gabriel Broussard Korr.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.2.0.</p>
</div>

    </footer>
</div>





  </body>
</html>
