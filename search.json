[{"path":"https://gbkorr.github.io/rcade/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2026 Gabriel Broussard Korr Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://gbkorr.github.io/rcade/articles/engine.html","id":"rom-and-ram","dir":"Articles","previous_headings":"","what":"1. ROM and RAM","title":"High-Level Engine Structure","text":"run game, ’ll use two objects: ROM RAM.1 ROM (rom.init()) contains everything static game— code, images, information draw game. RAM (ram.init()) stores everything dynamic— player coordinates, game timer, current inputs— constantly updated game run. structure particularly convenient two reasons. one, game code stored one object (ROM), games easy handle load— just need make ROM object edit , load premade one like SuperRrio. convenience , storing dynamic info one object (RAM), can easily copy object create savestate— snapshot game given moment can saved loaded later. allows engine robust, issues (like input registering) can rolled back (see vignette(\"rollback\")) earlier savestate rerun correctly.","code":""},{"path":"https://gbkorr.github.io/rcade/articles/engine.html","id":"making-and-running-a-game","dir":"Articles","previous_headings":"","what":"2. Making and Running a Game","title":"High-Level Engine Structure","text":"basic usage engine structured like : game dev creates adds game code, art, etc. ROM object player uses ROM initialize RAM object playing player runs game using RAM2 player starts additional R session send inputs game two R sessions referred display session, code happens game drawn, input session, player sends inputs game. code, four steps look like : game runs constantly responds inputs player input session. , player can ^C display session interrupt (pause) game inspect RAM object, continue game, even edit ROM.3","code":"#1 Game = rom.init({game stuff}) Game$morestuff = {additional game stuff}    #2 RAM = ram.init(Game)        #3 RAM = ram.run(Game)    #4 (in separate session/window) inputs.listen()"},{"path":"https://gbkorr.github.io/rcade/articles/engine.html","id":"the-gameloop","dir":"Articles","previous_headings":"","what":"3. The Gameloop","title":"High-Level Engine Structure","text":"RAM run, executes gameloop . code dedicated running engine, drawing game, running game logic, etc. called. gameloop involves four distinct systems: Game Code: Running game. Inputs: Interfacing player. Timing: Executing gameloop right pace. Rendering: Drawing game console. system full article (linked sections ) either describing demonstrating system.","code":""},{"path":"https://gbkorr.github.io/rcade/articles/engine.html","id":"game-code","dir":"Articles","previous_headings":"3. The Gameloop","what":"3.1 Game Code","title":"High-Level Engine Structure","text":"vignette(\"snake\") Game code run ROM$custom() made game dev. reads writes RAM things like respond player inputs, move characters around, trigger events like game end.","code":""},{"path":"https://gbkorr.github.io/rcade/articles/engine.html","id":"inputs","dir":"Articles","previous_headings":"3. The Gameloop","what":"3.2 Inputs","title":"High-Level Engine Structure","text":"vignette(\"inputs\") Input system serves let player interact game live runs. consists listener record player inputs code interact listener, well code turn recorded inputs something usable Game Code. documentation inputs.get() good description input pipeline, player pressing keyboard keys input interpreted game code.","code":""},{"path":"https://gbkorr.github.io/rcade/articles/engine.html","id":"timing","dir":"Articles","previous_headings":"3. The Gameloop","what":"3.3 Timing","title":"High-Level Engine Structure","text":"vignette(\"timing\") Timing system ensures game runs draws correct speed. involves speeding slowing game ahead behind “” (according desired speed, determined ROM$framerate), deciding whether draw given tick— game look smooth, drawing must happen game “caught ”.","code":""},{"path":"https://gbkorr.github.io/rcade/articles/engine.html","id":"rendering","dir":"Articles","previous_headings":"3. The Gameloop","what":"3.4 Rendering","title":"High-Level Engine Structure","text":"vignette(\"render\") Rendering system consists host functions dedicated rendering current scene—way objects organized onscreen given tick/gamestate—console, game displayed. involves: getting right sprite (image) object putting right place layer scene (render.sprite()) combining whole scene one object rendered (render.scene()) making object printable console (render.matrix())","code":""},{"path":"https://gbkorr.github.io/rcade/articles/engine.html","id":"alternative-methods-of-interaction","dir":"Articles","previous_headings":"","what":"4. Alternative Methods of Interaction","title":"High-Level Engine Structure","text":"default way interacting game using ram.run() inputs.listen(), couple options available.","code":""},{"path":"https://gbkorr.github.io/rcade/articles/engine.html","id":"listener-frame-advance","dir":"Articles","previous_headings":"4. Alternative Methods of Interaction","what":"4.1 Listener Frame Advance","title":"High-Level Engine Structure","text":"live game can suspended time inputting /pause input session. : player can input /tick advance one tick forward (draw scene ). player can type regular inputs, processed game next time /tick called (game resumed). player can resume live gameplay inputting /resume. behavior documented ?inputs.command. find method convenient next section, since staying input session allows fluid transition live tick--tick gameplay.","code":""},{"path":"https://gbkorr.github.io/rcade/articles/engine.html","id":"manual-advance","dir":"Articles","previous_headings":"4. Alternative Methods of Interaction","what":"4.2 Manual Advance","title":"High-Level Engine Structure","text":"Forgoing need listener session, game can also paused manipulated directly display session. gives user control altering RAM may especially useful debugging. done pausing game ^C (ends ram.run process). RAM object can manipulated freely: RAM = ram.tick(RAM) advances game one tick. RAM = ram.input(RAM, [input]) adds input RAM processed next tick. RAM = ram.run(RAM) resumes game (requiring input session interact) paused, RAM can also easily saved reloaded copying , following code:","code":"savestate_1 = RAM RAM = ram.run(RAM) #play the game a bit via the input session ^C RAM = savestate_1 #restore the savestate RAM = ram.run(RAM) #the game is now back to where it was when savestate_1 was saved"},{"path":"https://gbkorr.github.io/rcade/articles/engine.html","id":"gameloop-function-tree","dir":"Articles","previous_headings":"","what":"5. Gameloop Function Tree","title":"High-Level Engine Structure","text":"gameloop consists following nesting functions order: ram.run() start resume game Timing: ram.update() every tick (see vignette(\"timing\")) Inputs: inputs.get() inputs.read() inputs.command() commands sent inputs.rollback() inputs received late inputs.process() Game Code: ram.tick() RAM$ROM$custom() Rendering: render.ram() RAM$time > time.sec() render.object() every object RAM$objects render.animate() object’s sprite animated render.sprite() custom obj$draw() render.overlay() render.scene() render.overlay() every layer scene$layers render.matrix() tree can also found documentation ?ram.run.","code":""},{"path":"https://gbkorr.github.io/rcade/articles/guide.html","id":"how-to-play-a-game","dir":"Articles","previous_headings":"","what":"1. How to Play a Game","title":"Basic Package Usage","text":"play game, ’ll need two RStudio1 sessions open separate windows. One , ’ll call display session, display game’s graphics; relatively large window, ’ll want zoom cmd - equivalent. second sessions input session ’ll interact game starts. IMAGE GOOD SETUP two windows open, follow steps: sessions need load package library(rcade). display session, start game want play. recommend SuperRrio: , go input session run now able enter text input session control game! control scheme Super Rrio /D move SPACE jump. R works, press Enter every time want send input. jump right, ’d press keys W-SPACE-ENTER succession. GIF !","code":"quickload(SuperRrio) inputs.listen()"},{"path":"https://gbkorr.github.io/rcade/articles/guide.html","id":"prebuilt-games","dir":"Articles","previous_headings":"","what":"2. Prebuilt Games","title":"Basic Package Usage","text":"ROMs (games) ’ve made included package. run one, follow steps desired ROM quickload().","code":""},{"path":"https://gbkorr.github.io/rcade/articles/guide.html","id":"snake","dir":"Articles","previous_headings":"2. Prebuilt Games","what":"Snake","title":"Basic Package Usage","text":"IMAGE Classic Snake game controlled WASD. load ROM, ’ll prompted want use default settings change speed boundaries game.","code":"quickload(Snake)"},{"path":"https://gbkorr.github.io/rcade/articles/guide.html","id":"super_rrio","dir":"Articles","previous_headings":"2. Prebuilt Games","what":"Super_Rrio","title":"Basic Package Usage","text":"IMAGE","code":""},{"path":"https://gbkorr.github.io/rcade/articles/guide.html","id":"bad-apple","dir":"Articles","previous_headings":"2. Prebuilt Games","what":"Bad Apple","title":"Basic Package Usage","text":"IMAGE one isn’t game, just tech demo graphics engine. Running render video console, input session needed.","code":""},{"path":"https://gbkorr.github.io/rcade/articles/guide.html","id":"r2studio","dir":"Articles","previous_headings":"2. Prebuilt Games","what":"R2Studio","title":"Basic Package Usage","text":"IMAGE desc Pronounced “r-squared studio”— ’s pun Pearson r2, fact ’s RStudio RStudio! TODOTDO","code":""},{"path":"https://gbkorr.github.io/rcade/articles/guide.html","id":"making-games","dir":"Articles","previous_headings":"","what":"3. Making Games","title":"Basic Package Usage","text":"can make game rom.init(); vignette(\"Snake\") full devlog process making Snake ROM start finish. ’ve made ROM, can run just like games ! game articles go detail game logic technical implementations may useful advanced game development.","code":""},{"path":"https://gbkorr.github.io/rcade/articles/inputs.html","id":"overview","dir":"Articles","previous_headings":"","what":"1. Overview","title":"Input Handling","text":"Input system tall task communicating live game process. Trouble , R doesn’t make easy! R Games past thwarted fact R’s native method taking user input, base::readline(), fully suspends R process input given1. natural way around , course, just use two processes! ’s input system . use one Rstudio session run draw main game constantly, without interruption, use second session interact player. second session relay inputs first.","code":""},{"path":"https://gbkorr.github.io/rcade/articles/inputs.html","id":"recording-inputs","dir":"Articles","previous_headings":"","what":"2. Recording Inputs","title":"Input Handling","text":"Getting input user isn’t hard R— looping readline() lets us capture full text string input user every Enter press. actually use readLines(n=1) instead, exact thing doesn’t remove leading trailing whitespace. lets us use SPACE (’ ’) valid key actions.","code":""},{"path":"https://gbkorr.github.io/rcade/articles/inputs.html","id":"transmitting-inputs","dir":"Articles","previous_headings":"","what":"3. Transmitting Inputs","title":"Input Handling","text":"listening session sends inputs game session adding end dataframe stored .csv file, using utils::write.table(append=TRUE). R can read write .csvs quite quickly—–much faster can print text, example–—can game read .csv file every tick see new inputs created. file located? Luckily, R provides dedicated folder storing local data package: tools::R_user_dir(). Since player can type one window time, ’re really going multiple input sessions going , can just reuse .csv file time play game; ram.init() wipes file start game. Now, every tick, game reads contents .csv file figure .","code":""},{"path":"https://gbkorr.github.io/rcade/articles/inputs.html","id":"interpreting-inputs","dir":"Articles","previous_headings":"","what":"4. Interpreting Inputs","title":"Input Handling","text":"Ultimately, want input convey certain set keyboard keys interpreted pressed certain tick. ’s player ‘expecting’ input system . keys easy—– ’re already storing string characters can split see individual keys player pressed. get exact time.sec() (absolute time seconds) input, listener records, tick input happen ? can accomplished ways basically thing. convenience, settled approach converting timestamp directly tick number—tick input occur —interpreted game. game reads inputs .csv file, determines ones hasn’t seen , converts timestamps ticks, saves new inputs RAM$inputs. done inputs.get().","code":""},{"path":"https://gbkorr.github.io/rcade/articles/inputs.html","id":"timestamp-to-frame-conversion","dir":"Articles","previous_headings":"","what":"5. Timestamp-to-Frame Conversion","title":"Input Handling","text":"get timestamp tick occur ? tied game accomplishes frame Timing (see vignette(\"timing\")) general. timing system sync tick occur every 1/framerate seconds last resumed, can manually calculate time corresponds tick record time game resumed. math ?inputs.get. also want add slight amount input delay–— pretending inputs made little later really —inputs aren’t transmitted read instantly. , every input received slightly made, every input late!2","code":""},{"path":"https://gbkorr.github.io/rcade/articles/inputs.html","id":"processing-inputs","dir":"Articles","previous_headings":"","what":"6. Processing Inputs","title":"Input Handling","text":"whole process leaves us RAM$inputs, dataframe input strings corresponding ticks occur . Now game can, every tick, just look inputs correspond current tick, apply input . Inputs applied using character input string key ROM$keybinds, stores action keypress correspond — updates RAM$actions, game logic can read see , example, player pressed key JUMP frame. process detailed ?inputs.process.","code":""},{"path":"https://gbkorr.github.io/rcade/articles/inputs.html","id":"late-inputs","dir":"Articles","previous_headings":"","what":"7. Late Inputs","title":"Input Handling","text":", computer lag online latency, game receives input supposed happen? game designed able smoothly handle scenario— something many engines struggle . RAM constantly backs , can just ram.rollback() previous version rerun game. RAM$inputs rolled back, game reruns , ’ll now access inputs missed !","code":""},{"path":"https://gbkorr.github.io/rcade/articles/rcade.html","id":"manifest","dir":"Articles","previous_headings":"","what":"1. Manifest","title":"The 'rcade' Package","text":"package exist? now, games existed R take live input user. changes , provides powerful framework creating games. came project give opportunity build lot skills—package creation, documentation, etc.—working something genuinely fun cool.","code":""},{"path":"https://gbkorr.github.io/rcade/articles/rcade.html","id":"directory","dir":"Articles","previous_headings":"","what":"2. Directory","title":"The 'rcade' Package","text":"package comes full suite vignettes detailing every aspect things work. listed short description:","code":""},{"path":"https://gbkorr.github.io/rcade/articles/rcade.html","id":"general-vignettes","dir":"Articles","previous_headings":"2. Directory","what":"2.1 General Vignettes","title":"The 'rcade' Package","text":"vignette(\"guide\") goes use package play games. vignette(\"engine\") describes high-level structure game engine systems. vignette(\"snake\") provides full walkthrough game creation using package. [VIGS NEEDED: rrio, r2studio]","code":""},{"path":"https://gbkorr.github.io/rcade/articles/rcade.html","id":"systems-vignettes","dir":"Articles","previous_headings":"2. Directory","what":"2.2 Systems Vignettes","title":"The 'rcade' Package","text":"vignette(\"timing\") explains detail game runs right speed. vignette(\"inputs\") describes engine captures interprets user input. vignette(\"render\") details everything goes drawing game console.","code":""},{"path":"https://gbkorr.github.io/rcade/articles/rcade.html","id":"prebuilt-games","dir":"Articles","previous_headings":"","what":"3. Prebuilt Games","title":"The 'rcade' Package","text":"[COPY SECTIONS GUIDE VIGNETTE?]","code":""},{"path":"https://gbkorr.github.io/rcade/articles/rcade.html","id":"snake","dir":"Articles","previous_headings":"3. Prebuilt Games","what":"3.1 Snake","title":"The 'rcade' Package","text":"vignette(\"snake\") [IMAGE GAME] port classic game Snake, running quite smoothly. Demonstrates interactivity rcade well serves great guide ROM creation.","code":""},{"path":"https://gbkorr.github.io/rcade/articles/rcade.html","id":"super-rrio","dir":"Articles","previous_headings":"3. Prebuilt Games","what":"3.2 Super Rrio","title":"The 'rcade' Package","text":"[TODO TODO][]","code":""},{"path":"https://gbkorr.github.io/rcade/articles/rcade.html","id":"bad-apple","dir":"Articles","previous_headings":"3. Prebuilt Games","what":"3.3 Bad Apple","title":"The 'rcade' Package","text":"vignette(\"badapple\") [IMAGE] ROM proof concept graphical capabilities rcade, can comfortably play videos resolutions exceeding 64x64. Bad Apple canonical video demonstrate graphical capabilities hardware … shouldn’t really graphical capabilities. People run everything original IBM computers oscilloscopes calculators glitching pokemon run video ingame via ACE. ’m certainly first make CLI console, R. believe first time ’s done R console.","code":""},{"path":"https://gbkorr.github.io/rcade/articles/rcade.html","id":"r2studio","dir":"Articles","previous_headings":"3. Prebuilt Games","what":"3.4 R2Studio","title":"The 'rcade' Package","text":"vignette(\"r2studio\") [IMAGE] ’s RStudio RStudio!1 ROM draws little console plotting window, user can run R code sending input system. Running program pinnacle wacky software enginnering, mind.2 really shows robust rcade can pushed limits. (… yes, can run .)","code":""},{"path":"https://gbkorr.github.io/rcade/articles/rcade.html","id":"history-and-motivation","dir":"Articles","previous_headings":"","what":"4. History and Motivation","title":"The 'rcade' Package","text":"excellent resources3 detailing former state R gaming. Vanilla R games restricted text-based games; action games required shiny equivalent package take live input. longer! wanted make game base R! started joke idea pitched friends, ended developing full engine Spring 2025. engine bit different—– used -console ASCII display run simplified Super Smash Brothers-like game featured working multiplayer (!) using node.js server. worked quite well abandoned … fun making work. winter, realized excellent opportunity turn R package sake practice exhibition. Many concepts used package originate old engine, code new much nicer, fully documented!","code":""},{"path":"https://gbkorr.github.io/rcade/articles/rcade.html","id":"goals","dir":"Articles","previous_headings":"","what":"5. Goals","title":"The 'rcade' Package","text":"Adapting systems original project, package many goals: run base R dependencies! (excepting preinstalled packages like tools) work cohesive package high-quality, R-style code— e.g. proper handling objects, global assignments, CRAN compatibility. game engine, people can make games; original project used play one game designed . thorough documentation vignettes— blast write haven’t often gotten opportunity make . , convenient possible people use— much effort spent manicuring code documentation inter-reference cohesively maximize readability. UX top priority R package! ’m happy say project achieved every goal, pleasure develop. Enjoy!","code":""},{"path":[]},{"path":"https://gbkorr.github.io/rcade/articles/rcade.html","id":"style","dir":"Articles","previous_headings":"6. Notes","what":"6.1 Style","title":"The 'rcade' Package","text":"choose write R code way ’s slightly easier people unfamiliar R understand;4 mainly forgoing use <- declaring function returns explicitly. Additionally, sake organization, function names prefixed general context— e.g., functions pertaining “rendering process” take form render.foo(). S3 conventions (prefix indicates class function operates ) find immensely valuable tool writing understandable code.","code":""},{"path":"https://gbkorr.github.io/rcade/articles/rcade.html","id":"the-name-rcade","dir":"Articles","previous_headings":"6. Notes","what":"6.2 The Name ‘rcade’","title":"The 'rcade' Package","text":"name “rcade” perfect pass host reasons. Two packages already ‘exist’ name, don’t think cause conflict: deprecated bioconductor package removed bioconductor CRAN 2015. old github-package runs HTML5 games R. packages obscure nearly decade old— may R gods merciful usurping name.","code":""},{"path":"https://gbkorr.github.io/rcade/articles/rcade.html","id":"ai-disclaimer","dir":"Articles","previous_headings":"6. Notes","what":"6.3 AI Disclaimer","title":"The 'rcade' Package","text":"LLMs used5 making package. writing code done !","code":""},{"path":"https://gbkorr.github.io/rcade/articles/rcade.html","id":"but-can-it-run-doom","dir":"Articles","previous_headings":"","what":"7. But Can it Run Doom?","title":"The 'rcade' Package","text":"Absolutely, ’m good making 3D games. Someone else port.","code":""},{"path":"https://gbkorr.github.io/rcade/articles/render.html","id":"goals","dir":"Articles","previous_headings":"","what":"1. Goals","title":"Drawing to Console","text":"Game graphics need way display graphics. rcade intended run live-input games relatively high fps (frames per second), needs graphical system capable redrawing desired framerate. Past achieving , ’s matter getting high resolution feasible.","code":""},{"path":"https://gbkorr.github.io/rcade/articles/render.html","id":"console-graphics","dir":"Articles","previous_headings":"","what":"2. Console Graphics","title":"Drawing to Console","text":"R plotting far slow fulfill needs. Instead, turn canonical apporach— rendering via console. Pixels can printed characters appropriate locations, giving low-resolution highly usable medium rendering images. fact, RStudio allows zoom considerable amount, allowing console fit upwards 800x600 characters. couple issues come . First, characters much taller wide, use pairs characters—usually brackets: []—create square pixels.","code":""},{"path":"https://gbkorr.github.io/rcade/articles/render.html","id":"pixel-art-in-the-console","dir":"Articles","previous_headings":"2. Console Graphics","what":"2.1 Pixel Art in the Console","title":"Drawing to Console","text":"Printing console like quite simple. Strings like quickly interpreted users imagery: run issue. Art can printed console, ’s guarantee shows right position… Luckily, clearning console means next message always show place— can just clear console every time draw. RStudio supports escape character cat('\\f')1, though R.app unfortunately doesn’t. Redrawing canvas cat works quite well, takes long enough cause flickering higher resolutions. sadly unavoidable. Games can still played enjoyed flickering, however, usually impact true framerate.","code":"cat('   []  []   []  []  []      []   [][][] ') #>  #>   []  [] #>   []  [] #>  #> []      [] #>   [][][]"},{"path":"https://gbkorr.github.io/rcade/articles/render.html","id":"storing-pixel-art","dir":"Articles","previous_headings":"2. Console Graphics","what":"2.2 Storing Pixel Art","title":"Drawing to Console","text":"want , can’t just store everything strings— nightmare work clunky strings edit. Instead, can write function, render.matrix(), convert directly bitmap matrix drawable string: palette defines convert bitmap values character pixels— default, 1 encodes filled (black) pixels 0 2 white. Values 0 used elsewhere rendering system represent transparency, assume white background draw white.","code":"render.matrix = function(M, palette = c('  ', '[]', '  ')){   #we assume the bitmap to be positive integers      #attach a line of -1 values on the rightmost column to turn into newlines   M = rbind(t(M),-1) #transpose to match the orientation of print(M)      #add two to make all values work as vector indices   M = M + 2      #convert matrix to vector of strings using its values as indices   str = c('\\n',palette)[M]        cat(str, sep='') #collapse vector and print }  render.matrix(matrix(c(0,0,1,0,0,0,0,1,1,1,0,1,0,0,0,1,1,1,0,1,0,0,0,1,0,0,1,0), ncol = 7)) #>     []  []     #>     []  []     #> []          [] #>   [][][][][]"},{"path":"https://gbkorr.github.io/rcade/articles/render.html","id":"sprites","dir":"Articles","previous_headings":"","what":"3. Sprites","title":"Drawing to Console","text":"render.matrix() lets us print pixel art console matrix encodes . package calls matrix sprite. Typically, game stores handles sprites directly (matrices), game dev expected generate . package provides convenient tool : render.makesprite().","code":"#A sprite is anything that can be printed by render.matrix(): sprite = matrix(c(0,0,1,0,0,0,0,1,1,1,0,1,0,0,0,1,1,1,0,1,0,0,0,1,0,0,1,0), ncol = 7)  print(sprite) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] #> [1,]    0    0    1    0    1    0    0 #> [2,]    0    0    1    0    1    0    0 #> [3,]    1    0    0    0    0    0    1 #> [4,]    0    1    1    1    1    1    0  render.matrix(sprite) #>     []  []     #>     []  []     #> []          [] #>   [][][][][]"},{"path":"https://gbkorr.github.io/rcade/articles/render.html","id":"sprite-creation","dir":"Articles","previous_headings":"3. Sprites","what":"3.1 Sprite Creation","title":"Drawing to Console","text":"render.makesprite() converts user text sprite intuitively possible. goal function remove need confusing matrix manipulation, follow principle WYSIWYG maximal convenience: “see get”. limitation character strings look bit different square pixels, overall ’ve found function extremely useful. Sometimes, ’s easier create sprite manually matrix. especially useful geometric procedural shapes:","code":"sprite = render.makesprite('   OOO  O   O O     O O     O O     O  O   O   OOO ')  render.matrix(sprite) #>     [][][]     #>   []      []   #> []          [] #> []          [] #> []          [] #>   []      []   #>     [][][] box = matrix(1,8,16) box[2:(nrow(box) - 1), 2:(ncol(box) - 1)] = 0  render.matrix(box) #> [][][][][][][][][][][][][][][][] #> []                            [] #> []                            [] #> []                            [] #> []                            [] #> []                            [] #> []                            [] #> [][][][][][][][][][][][][][][][]"},{"path":"https://gbkorr.github.io/rcade/articles/render.html","id":"drawing-multiple-things-at-once","dir":"Articles","previous_headings":"","what":"4. Drawing Multiple Things at Once","title":"Drawing to Console","text":"render.matrix() lets us render individual sprite console. natural next step somehow combine sprites can drawn together one image. general approach take big, empty, rectangular ‘background’ sprite, edit sprites: issue replacing values directly matrix[:b,c:d] always overwrite original value. can get around code like : whole process automated render.overlay(), also clips sprite ensure everything kept within bounds matrix.","code":"sprite = render.makesprite('  O O  O O  O   O  OOO ')  background = matrix(0,12,10)  #paste in sprites background[1:5,1:5] = sprite background[2 + 1:5, 5 + 1:5] = sprite background[7 + 1:5, 3 + 1:5] = sprite  render.matrix(background) #>   []  []             #>   []  []             #>             []  []   #> []      []  []  []   #>   [][][]             #>           []      [] #>             [][][]   #>         []  []       #>         []  []       #>                      #>       []      []     #>         [][][] overwrite = sprite   overwrite[sprite == 0] = matrix[a:b,c:d][sprite == 0]    #replace values of 0 with the value underneath         matrix[a:b,c:d] = overwrite circle = render.makesprite('   OOO  O   O O     O O     O O     O  O   O   OOO ')  background = matrix(0,9,9)  background[1:7,1:7] = circle  overwrite = circle overwrite[circle == 0] = background[1 + 1:7,2 + 1:7][circle == 0]  background[1 + 1:7,2 + 1:7] = overwrite  render.matrix(background) #>     [][][]         #>   []    [][][]     #> []    []    [][]   #> []  []      []  [] #> []  []      []  [] #>   [][]    []    [] #>     [][][]    []   #>         [][][]     #> background = matrix(0,9,14)  background = render.overlay(background, circle, 1, 1) background = render.overlay(background, circle, 3, 3) background = render.overlay(background, circle, 11, 1)  render.matrix(background) #>     [][][]              [][] #>   []      []          []     #> []      [][][]      []       #> []    []    [][]    []       #> []  []      []  []  []       #>   [][]    []    []    []     #>     [][][]      []      [][] #>       []      []             #>         [][][]"},{"path":"https://gbkorr.github.io/rcade/articles/render.html","id":"layers-and-the-scene","dir":"Articles","previous_headings":"","what":"5. Layers and the Scene","title":"Drawing to Console","text":"Now can combine sprites, run issue convenient ordering. sprites drawn top, achieve ? rcade addresses render.scene(). create ‘scene’ object containing layers, background previous section. engine draws sprites onto specific layers, finally takes layers overlays one--one produce final matrix drawn. [like image : sprites -> layer (like stickers), layers stacked like paper] draw sprite onto layer, use render.sprite(), really just wrapper render.overlay() work layer.","code":""},{"path":"https://gbkorr.github.io/rcade/articles/render.html","id":"the-inversion-layer","dir":"Articles","previous_headings":"5. Layers and the Scene","what":"5.1 The Inversion Layer","title":"Drawing to Console","text":"monochrome displays, ’ll sometimes run issue something important, like text, drawn black background becomes impossible see. simple fix , rather drawing text set color, just allow invert color ’s drawn — way ’ll always visible2. rcade implements dedicated scene layer called scene$layers$invert, drawn last inverts anything covers. uses invert argument render.overlay().","code":""},{"path":"https://gbkorr.github.io/rcade/articles/render.html","id":"drawing-the-ram","dir":"Articles","previous_headings":"","what":"6. Drawing the RAM","title":"Drawing to Console","text":"game rendering process involves drawing every game object onto one scene. automated render.ram(), called every frame— see vignette(\"timing\"). function, scene object created, game object (RAM$objects) drawn render.sprite().","code":""},{"path":"https://gbkorr.github.io/rcade/articles/render.html","id":"sprites-in-rom","dir":"Articles","previous_headings":"6. Drawing the RAM","what":"6.1 Sprites in ROM","title":"Drawing to Console","text":"convention, sprites/images stored ROM possible.3 stored name ROM$sprites, referenced rendering process.","code":""},{"path":"https://gbkorr.github.io/rcade/articles/render.html","id":"object-drawing-specifics","dir":"Articles","previous_headings":"6. Drawing the RAM","what":"6.2 Object Drawing Specifics","title":"Drawing to Console","text":"Object drawing handled render.object(), figures draw object render.sprite(). Objects drawn $spritename, indicates sprite use. character string corresponding sprite matrix ROM$sprites— render.object() retrieves sprite ROM$sprites feeds render.sprite(). Objects quite optional properties, listed ?render.object. control things like position whether particular object swap around colors sprite. ‘palette swapping’ colors like easy way increase variety images game without needing make new sprites.","code":""},{"path":"https://gbkorr.github.io/rcade/articles/render.html","id":"custom-drawing-code","dir":"Articles","previous_headings":"6. Drawing the RAM","what":"6.3 Custom Drawing Code","title":"Drawing to Console","text":"often useful override basic drawing behavior— example, object’s sprite generated procedurally rather copying static sprite ROM$sprites. can done defining obj$draw(), run instead regular code render.object(). Note obj$draw() return scene, thus must include code changes values object ; changes occur game code ROM$custom() (see vignette(\"engine\")).","code":""},{"path":"https://gbkorr.github.io/rcade/articles/render.html","id":"animations","dir":"Articles","previous_headings":"","what":"7. Animations","title":"Drawing to Console","text":"Now topic animations. game object change sprite every frames, …………. [VIDEO EXAMPLE] achieved calling render.animate() retrieve object’s sprite render.object(). sprites want animate, instead storing just pixel art matrix, store list containing frame animation information animation. render.animate() parses figure frame animation return. can also specify whether animation loop transition different sprite completing. NEED VIDEO EXAMPLE game dev, ’s needed animate sprite store complex sprite ROM$sprites. convenient! Sprite animations can also tested render.test_animation ensure look .","code":""},{"path":"https://gbkorr.github.io/rcade/articles/render.html","id":"text","dir":"Articles","previous_headings":"","what":"8. Text","title":"Drawing to Console","text":"Now topic rendering piece text ingame. just render.sprite() character individually, needlessly ineffecient; instead, best solution combine characters one sprite render single render.sprite() call. purpose render.text().","code":""},{"path":"https://gbkorr.github.io/rcade/articles/render.html","id":"fonts","dir":"Articles","previous_headings":"8. Text","what":"8.1 Fonts","title":"Drawing to Console","text":"first, store sprites character? rcade handles pretty simply— font objects contain information size/spacing characters, also contain list sprites character. ?render.makefont provides detail , inspecting View(fonts.3x3) may useful well.","code":""},{"path":"https://gbkorr.github.io/rcade/articles/render.html","id":"render-text","dir":"Articles","previous_headings":"8. Text","what":"8.2 render.text()","title":"Drawing to Console","text":"basic functionality render.text() stitching together character sprites desired (default) spacing. outputs sprite, put ROM$sprites draw fly obj$draw(). Putting text inversion layer (render.sprite(...layer = 'invert') may helpful ensure text readable black white backgrounds. Additionally, code included provide option wrap words fit given width pixels, align left/right/center.4 ’s example render.text()’s stitching: ?render.text provides examples capabilities.","code":"#manually stitching letters with a 1-wide gap between render.matrix(   cbind(     fonts.3x3$sprites$T,     matrix(0,3,1),     fonts.3x3$sprites$E,     matrix(0,3,1),     fonts.3x3$sprites$X,     matrix(0,3,1),     fonts.3x3$sprites$T   ) ) #> [][][]  [][][]  []  []  [][][] #>   []    [][]      []      []   #>   []    [][][]  []  []    []  #render.text() does this automatically render.matrix(   render.text('text', kerning = 1)   ) #>                                  #> [][][]  [][][]  []  []  [][][]   #>   []    [][]      []      []     #>   []    [][][]  []  []    []     #>"},{"path":"https://gbkorr.github.io/rcade/articles/rollback.html","id":"overview","dir":"Articles","previous_headings":"","what":"1. Overview","title":"Rollback in the rcade Engine","text":"Suppose two players playing game online. computers exchanging information buttons ’re pressing keep games sync. now, one players’ internet falters second. player tries jump; time computer sends “player 1 jumped” player, ’s whole second since tried jump. Now !? can’t just keep running game, totally different things happen players’ screens. traditional workaround make scenario impossible pausing players’ games time internet lag occurred. problem: pausing games randomly makes awful, choppy experience! modern games use different solution, never pauses interrupts game. game realizes something received late like , game engine rewinds game input happened, fast-forwards back present, repeating inputs happened. called rollback. technique creates smooth experience solves problem. limitations1, ’s usually much better old solution.","code":""},{"path":"https://gbkorr.github.io/rcade/articles/rollback.html","id":"online","dir":"Articles","previous_headings":"1. Overview","what":"1.1 Online?","title":"Rollback in the rcade Engine","text":"“Wait minute. Playing online? rcade doesn’t online!” ’s designed ! sometime, ’ll make addon package lets . rollback system isn’t really relevant singleplayer games. built engine : ’s good practice makes robust engine. makes engine easily extendable multiplayer. little worried reading inputs.csv file might take long inputs feel snappy. Luckily, ’s instantaneous everything else. , rcade structures way makes rollbacks convenient effective. ?","code":""},{"path":"https://gbkorr.github.io/rcade/articles/rollback.html","id":"rolling-back","dir":"Articles","previous_headings":"","what":"2. Rolling Back","title":"Rollback in the rcade Engine","text":"’ve just received input supposed already happened. resolve , restore previous gamestate, rerun game back present! process input correct time now . Functionality restore previous version baked engine. RAM continually refreshes2 copy 2 seconds prior3 use purpose. copy restored ram.rollback(), just calls utils::modifyList overwrite RAM values backup. version restored, game two seconds behind present. Luckily, timing system (explained detail vignette(\"timing\")) automatically deals situation catching present quickly possible. catches , inputs reapplied occurred. works inputs stored one dataframe—RAM$inputs (isn’t rolled back)—game cares inputs correspond current frame RAM. See vignette(\"inputs\") ?inputs.process details Input system.","code":""},{"path":"https://gbkorr.github.io/rcade/articles/rollback.html","id":"rng","dir":"Articles","previous_headings":"","what":"3. RNG","title":"Rollback in the rcade Engine","text":"RAM stores RNG just like R session. Backups restore RNG state, rollbacks experience random events happened originally, ’d expect. RAM RNG can set manually ram.set_rng().","code":""},{"path":"https://gbkorr.github.io/rcade/articles/snake.html","id":"engine-structure","dir":"Articles","previous_headings":"","what":"1. Engine Structure","title":"Snake Devlog","text":"ROM object (list) made rom.init() package can use play game. ROM contains static data game— game logic, sprites, . ’re building article. ROM, play making RAM object—stores dynamic data game—running ram.run(). runs game code ROM, references writes variables RAM. ’ll see game code article works RAM. vignette(\"rcade.guide\") provides overview process playing games, vignette(\"rcade.engine\") describes ROM/RAM little detail.","code":""},{"path":"https://gbkorr.github.io/rcade/articles/snake.html","id":"setup","dir":"Articles","previous_headings":"","what":"2. Setup","title":"Snake Devlog","text":"start, make decisions game work. snake controlled WASD, since R can’t capture arrow key presses. speed snake determined game’s framerate, since ’s point drawing faster . ’ll use arbitrary game area 16x8 now, change later.","code":""},{"path":"https://gbkorr.github.io/rcade/articles/snake.html","id":"rom-initialization","dir":"Articles","previous_headings":"2. Setup","what":"2.1 ROM Initialization","title":"Snake Devlog","text":"start, create ROM object. ’s can add function (rom.init()), need now; ’ll add additional properties object throughout article. far, ’ve: set game area 16x8 set framerate 2 frames per second created single sprite called “pixel” 1x1 pixel game automatically uses default WASD controls:1","code":"Snake = rom.init(16,8,framerate=2,sprites=list(pixel=matrix(1))) #Snake$keybinds = c(w = 'up', a = 'left', s = 'down', d = 'right')"},{"path":"https://gbkorr.github.io/rcade/articles/snake.html","id":"moving-the-snake","dir":"Articles","previous_headings":"","what":"3. Moving the Snake","title":"Snake Devlog","text":"first step make snake head object, player controls.","code":""},{"path":"https://gbkorr.github.io/rcade/articles/snake.html","id":"initialization","dir":"Articles","previous_headings":"3. Moving the Snake","what":"3.1 Initialization","title":"Snake Devlog","text":"’ll initialize object Snake$startup, runs RAM initialized. want create objects used later— ’s like top code file. snake (head object) starts center screen direction ‘neutral’ indicate hasn’t started moving yet.","code":"Snake$startup = function(RAM){   RAM$objects$head = list(         x = floor(RAM$ROM$screen.width / 2),         y = floor(RAM$ROM$screen.height / 2),            spritename = 'pixel',            direction = 'neutral'     )   return(RAM) }"},{"path":"https://gbkorr.github.io/rcade/articles/snake.html","id":"control","dir":"Articles","previous_headings":"3. Moving the Snake","what":"3.2 Control","title":"Snake Devlog","text":"’ll control snakehead changing $direction. can checking RAM$actions player-input directions, setting head$direction new valid direction input. want code run every tick Snake$custom(), instead cluttering function, can make new function call Snake$custom(). can’t just define new function basic R environment— RAM way access environment. instead make part ROM. , RAM can run RAM$ROM$set_direction(), since RAM access copy ROM.","code":"Snake$set_direction = function(RAM){   #name of the actions pressed on this tick, or NULL   actions = names(RAM$actions)[which(RAM$actions == TRUE)]      #print the direction so we know it's working   RAM$echo = paste(actions,collapse = ' ')       #set head direction   if (length(actions)) RAM$objects$head$direction = actions[[1]]       return(RAM) }"},{"path":"https://gbkorr.github.io/rcade/articles/snake.html","id":"movement","dir":"Articles","previous_headings":"3. Moving the Snake","what":"3.3 Movement","title":"Snake Devlog","text":"Now move head based direction.","code":"Snake$move_head = function(RAM){   head = RAM$objects$head #for typing convenience        print(head)   #convert direction name to x and y     direction = list(       'neutral' = c(0,0),         'left'= c(-1,0),         'right' = c(1,0),         'up' = c(0,-1),         'down' = c(0,1)     )[[head$direction]]      head$x = head$x + direction[1]     head$y = head$y + direction[2]      RAM$objects$head = head #push changes          return(RAM) }"},{"path":"https://gbkorr.github.io/rcade/articles/snake.html","id":"testing","dir":"Articles","previous_headings":"3. Moving the Snake","what":"3.4 Testing","title":"Snake Devlog","text":"Putting together, already working prototype can control head!","code":"Snake = rom.init(16,8,framerate=2,sprites=list(pixel=matrix(1)))  #define helper functions (see preceding sections) Snake$set_direction = function... Snake$move_head = function...  Snake$startup = function(RAM){   RAM$objects$head = list(         x = floor(RAM$ROM$screen.width / 2),         y = floor(RAM$ROM$screen.height / 2),         spritename = 'pixel',         direction = 'neutral'     )   return(RAM) }  Snake$custom = function(RAM){   RAM = RAM$ROM$set_direction(RAM)      RAM = RAM$ROM$move_head(RAM)       return(RAM)   }  RAM = ram.init(Snake) #initialize RAM RAM = ram.run(RAM) #run game with RAM"},{"path":"https://gbkorr.github.io/rcade/articles/snake.html","id":"border","dir":"Articles","previous_headings":"","what":"4. Border","title":"Snake Devlog","text":"Next, let’s make nice border game know play area ends. can generating sprite Snake$startup: want make sprite dynamically like game can played different resolutions— hard-coded sprite, wouldn’t always fit!","code":"Snake$make_border = function(RAM){   #make border sprite   box = matrix(1,RAM$ROM$screen.height,RAM$ROM$screen.width)   box[2:(nrow(box) - 1), 2:(ncol(box) - 1)] = 2      #push this sprite to ROM$sprites   RAM$ROM$sprites$border = box      #make object to display sprite   RAM$objects$border = list(spritename='border')     return(RAM)  } #> [][][][][][][][][][][][][][][][] #> []                            [] #> []                            [] #> []            []              [] #> []                            [] #> []                            [] #> []                            [] #> [][][][][][][][][][][][][][][][]"},{"path":"https://gbkorr.github.io/rcade/articles/snake.html","id":"segments","dir":"Articles","previous_headings":"","what":"5. Segments","title":"Snake Devlog","text":"Time add segments snake. ’s simple trick avoid keep track whole snake : Every tick, snake head moves new tile. Spawn segment empty tile head just left. Delete oldest segment spawned, unless apple eaten tick. produces exactly behavior want, since “tail” snake always corresponds oldest segment.","code":""},{"path":"https://gbkorr.github.io/rcade/articles/snake.html","id":"spawn-segment","dir":"Articles","previous_headings":"5. Segments","what":"5.1 Spawn Segment","title":"Snake Devlog","text":"New segments spawned frame Snake$custom moving head: use ram.new_object() add nameless objects RAM$objects.","code":"Snake$spawn_segment = function(RAM){   #spawn new tail segment   RAM = ram.new_object(RAM, list(     x = RAM$objects$head$x,     y = RAM$objects$head$y,        #used to find which objects are tail objects     is_segment = TRUE,         #tick on which this segment spawned     time_created = RAM$ticks,         spritename = 'pixel'   ))    return(RAM)   }"},{"path":"https://gbkorr.github.io/rcade/articles/snake.html","id":"remove-tail","dir":"Articles","previous_headings":"5. Segments","what":"5.2 Remove Tail","title":"Snake Devlog","text":"can loop objects, find oldest segment, remove . WARNING: R handles nested objects, RAM$objects always iterated (1:length(RAM$objects)). Attempting (obj RAM$objects) work.","code":"Snake$remove_tail = function(RAM){   oldest_time = Inf   oldest_index = NULL   for (i in 1:length(RAM$objects)){     obj = RAM$objects[[i]]        if (!is.null(obj$is_segment)){ #obj has $is_segment property         if (obj$time_created < oldest_time){ #object is oldest so far             oldest_time = obj$time_created             oldest_index = i         }     }   }   #remove oldest segment   RAM$objects = RAM$objects[-oldest_index]       return(RAM) }"},{"path":"https://gbkorr.github.io/rcade/articles/snake.html","id":"testing-1","dir":"Articles","previous_headings":"5. Segments","what":"5.3 Testing","title":"Snake Devlog","text":"test segments, ’ll make code snake grow. snake grow time don’t delete tail segment, let’s prevent code running every, say, 5 ticks. Let’s also speed game little ’s easier test.","code":"Snake = rom.init(16,8,framerate=5,sprites=list(pixel=matrix(1)))  #helper functions from before Snake$set_direction = function... Snake$move_head = function... Snake$make_border = function... Snake$spawn_segment = function... Snake$remove_tail = function...  Snake$startup = function(RAM){     #make border     RAM = RAM$ROM$make_border(RAM)        #make head     RAM$objects$head = list(         x = floor(RAM$ROM$screen.width / 2),         y = floor(RAM$ROM$screen.height / 2),         spritename = 'pixel',         direction = 'neutral'     )            return(RAM) }  Snake$custom = function(RAM){   #only do segment stuff once the snake starts moving    if (RAM$objects$head$direction != 'neutral'){     RAM = RAM$ROM$spawn_segment(RAM)           #skip this every fifth tick to grow the snake     if (RAM$ticks %% 5 != 0) RAM = RAM$ROM$remove_tail(RAM)    }          #move snake   RAM = RAM$ROM$set_direction(RAM)   RAM = RAM$ROM$move_head(RAM)       return(RAM)   }  quickload(Snake)"},{"path":"https://gbkorr.github.io/rcade/articles/snake.html","id":"quickload","dir":"Articles","previous_headings":"5. Segments","what":"5.4 quickload()","title":"Snake Devlog","text":"per vignette(\"engine\"), ‘correct’ way using ROM initialize RAM ram.init() run ram.run() (section 3.4). gets inconvenient , made wrapper function quickload() automatically. manual method still useful need control RAM want rename RAM object. execute two functions environment quickload() called , typed two lines :","code":"RAM = ram.init(ROM) RAM = ram.run(RAM)"},{"path":"https://gbkorr.github.io/rcade/articles/snake.html","id":"debugging","dir":"Articles","previous_headings":"","what":"6. Debugging","title":"Snake Devlog","text":"sake demonstration, ’m going introduce difficult bug walk debugging process . Let’s say accidentally mistyped line Snake$remove_tail like : accidentally deletes every object except snake’s tail. can figure code? Now get error message snake starts moving: (see ?ram.help details message) looks like list isn’t keyed properly.","code":"RAM$objects = RAM$objects[oldest_index] Traceback: [[1]] if (!RAM$paused) RAM = ram.tick(RAM)  [[2]] RAM = RAM$ROM$custom(RAM)  [[3]] RAM = RAM$ROM$move_head(RAM)  Call: list(neutral = c(0, 0), left = c(-1, 0), right = c(1, 0), up = c(0,      -1), down = c(0, 1))[[head$direction]]  Error: attempt to select less than one element in get1index"},{"path":"https://gbkorr.github.io/rcade/articles/snake.html","id":"printing","dir":"Articles","previous_headings":"6. Debugging","what":"6.1 Printing","title":"Snake Devlog","text":"put print() calls game code, ’ll see game crashes; normally, ’d hidden console wiped every frame. useful debugging. reminder, want something can see gameplay, value(s) RAM$echo printed game frame. let’s try using figure ’s going list call. traceback tells us error occurring Snake$move_head(), let’s try adding print(head$direction) right line crashes. printed NULL, seems head doesn’t exist moment. ’s much info ’re going get; one tougher bugs2 doesn’t tell us exactly ’s happening. Knowing RAM$objects$head getting deleted somewhere, best can look code every line change RAM$objects RAM$objects$head. ’s many moment, hopefully notice incorrect line can correct .","code":"NULL Traceback: [[1]]..."},{"path":"https://gbkorr.github.io/rcade/articles/snake.html","id":"game-end","dir":"Articles","previous_headings":"","what":"7. Game End","title":"Snake Devlog","text":"fixed, back developing game. ’s time check player loses. fairly simple— just see snake head bounds (hit wall) overlapping segment (hit ). ’ll make another function help check overlap. (’ll also reusing function see Snake touches apple!)","code":"#returns true if both objects are at the same coordinates Snake$overlap = function(obj1, obj2){     if (obj1$x == obj2$x && obj1$y == obj2$y) return(TRUE)     else return(FALSE) } Snake$check_game_end = function(RAM){     end_game = FALSE          #out of bounds     if (       RAM$objects$head$x < 2 ||         RAM$objects$head$x > RAM$ROM$screen.width - 1 ||         RAM$objects$head$y < 2 ||         RAM$objects$head$y > RAM$ROM$screen.height - 1     ) end_game = TRUE          #check overlap with segment     #using the same loop from Snake$remove_segment to iterate over the segments     for (i in 1:length(RAM$objects)){             obj = RAM$objects[[i]]             if (!is.null(obj$is_segment)){                 if (RAM$ROM$overlap(RAM$objects$head, obj)) end_game = TRUE             }     }          #stop the game when you lose     if (end_game) RAM$ROM$end_game(RAM)          return(RAM) }  Snake$end_game = function(RAM){         cat('Game over!')         ram.end() #stops the game }"},{"path":[]},{"path":"https://gbkorr.github.io/rcade/articles/snake.html","id":"initialization-1","dir":"Articles","previous_headings":"8. Apple","what":"8.1 Initialization","title":"Snake Devlog","text":"First make Apple object Snake$startup. needs coordinates sprite!","code":"RAM$objects$apple = list(     x = sample(2:(RAM$ROM$screen.width - 1),1), #random location     y = sample(2:(RAM$ROM$screen.height - 1),1),      spritename = 'pixel' )"},{"path":"https://gbkorr.github.io/rcade/articles/snake.html","id":"logic","dir":"Articles","previous_headings":"8. Apple","what":"8.2 Logic","title":"Snake Devlog","text":"game logic apple : Spawn apple somewhere empty. apple eaten (overlaps snake head), grow Snake (suppress tail removal). Repeat. ’ll like Snake$custom: now define Snake$eat_apple. move apple new, unoccupied location. Later ’ll put little code check player filled area won, since hang loop.","code":"if (RAM$ROM$overlap(RAM$objects$head,RAM$objects$apple)){     RAM = RAM$ROM$eat_apple(RAM) #eat apple } else {     RAM = RAM$ROM$remove_tail(RAM) } #moves the apple Snake$eat_apple = function(RAM){     valid = FALSE #is the apple in a valid location?          #loop until the apple is in a valid (unoccupied) location     while (!valid){         valid = TRUE          #new random location         RAM$objects$apple$x = sample(2:(RAM$ROM$screen.width - 1),1)         RAM$objects$apple$y = sample(2:(RAM$ROM$screen.height - 1),1)          #overlapping anything? check all the segments again         for (i in 1:length(RAM$objects)){             obj = RAM$objects[[i]]             if (!is.null(obj$is_tail)){                 if (RAM$ROM$overlap(RAM$objects$apple,obj)) {                      #overlaps something, break out and try again with a new location                     valid = FALSE                     break                 }             }         }     }      return(RAM) }"},{"path":"https://gbkorr.github.io/rcade/articles/snake.html","id":"testing-2","dir":"Articles","previous_headings":"8. Apple","what":"8.3 Testing","title":"Snake Devlog","text":"Now code looks like :","code":"Snake = rom.init(16,8,framerate=5,sprites=list(pixel=matrix(1)))  #helper functions from before Snake$set_direction = function... Snake$move_head = function... Snake$make_border = function... Snake$spawn_segment = function... Snake$remove_tail = function... Snake$eat_apple = function... Snake$check_game_end = function... Snake$end_game = function...  Snake$startup = function(RAM){     #make border     RAM = RAM$ROM$make_border(RAM)        #make head     RAM$objects$head = list(         x = floor(RAM$ROM$screen.width / 2),         y = floor(RAM$ROM$screen.height / 2),         spritename = 'pixel',         direction = 'neutral'     )          #make apple     RAM$objects$apple = list(             x = sample(2:(RAM$ROM$screen.width - 1),1), #random location             y = sample(2:(RAM$ROM$screen.height - 1),1),                      spritename = 'pixel'         )            return(RAM) }  Snake$custom = function(RAM){   #only do segment stuff once the snake starts moving    if (RAM$objects$head$direction != 'neutral'){     RAM = RAM$ROM$spawn_segment(RAM)           #eat apple or remove tail     if (RAM$ROM$overlap(RAM$objects$head,RAM$objects$apple)){             RAM$echo = 'Apple Eaten' #print this so we know it works              RAM = RAM$ROM$eat_apple(RAM) #eat apple         } else {             RAM = RAM$ROM$remove_tail(RAM)         }   }          #move snake   RAM = RAM$ROM$set_direction(RAM)   RAM = RAM$ROM$move_head(RAM)       #check for game end   RAM = RAM$ROM$check_game_end(RAM)      return(RAM)   }  quickload(Snake)"},{"path":"https://gbkorr.github.io/rcade/articles/snake.html","id":"polish","dir":"Articles","previous_headings":"","what":"9. Polish","title":"Snake Devlog","text":"Time bunch cleanup QoL.","code":""},{"path":"https://gbkorr.github.io/rcade/articles/snake.html","id":"u-turn-prevention","dir":"Articles","previous_headings":"9. Polish","what":"9.1 U-Turn Prevention","title":"Snake Devlog","text":"Currently, ’s nothing stopping going back direction just came , make instantly collide lose. can add check Snake$set_direction() prevent : ’ve also gotten rid action echo, since ’re confident works point.","code":"Snake$set_direction = function(RAM){   #name of the actions pressed on this tick, or NULL   actions = names(RAM$actions)[which(RAM$actions == TRUE)]      #set head direction   if (length(actions)) {     action = actions[[1]]          if (action != c( #forbidden direction combos                     neutral = '', #can do any direction from neutral                     left = 'right',                     right = 'left',                     up = 'down',                     down = 'up'                 )[RAM$objects$head$direction]         ){             RAM$objects$head$direction = action         }   }      return(RAM) }"},{"path":"https://gbkorr.github.io/rcade/articles/snake.html","id":"counting-segments-and-survival","dir":"Articles","previous_headings":"9. Polish","what":"9.2 Counting Segments and Survival","title":"Snake Devlog","text":"neat display stats game ends, like big snake long survived . can record snake length incrementing counter, RAM$segments, Snake$add_segment(), decrementing Snake$remove_segment. Similarly, can track number ticks survived incrementing counter every tick player starts moving, Snake$custom(). just initialize counters Snake$startup() like : can add variables Game message: also want make check player completely filled space snake, prevent loop earlier hanging. can adding check beginning Snake$eat_apple(): end game loop chance start.","code":"Snake$spawn_segment = function(RAM){     RAM$segments = RAM$segments + 1 #increment segments          #spawn new tail segment     RAM = ram.new_object(RAM, list(         x = RAM$objects$head$x,         y = RAM$objects$head$y,          #used to find which objects are tail objects         is_segment = TRUE,          #tick on which this segment spawned         time_created = RAM$ticks,          spritename = 'pixel'     ))      return(RAM) }  Snake$remove_tail = function(RAM){     RAM$segments = RAM$segments - 1 #decrement segments          oldest_time = Inf     oldest_index = NULL     for (i in 1:length(RAM$objects)){         obj = RAM$objects[[i]]          if (!is.null(obj$is_segment)){ #obj has $is_segment property             if (obj$time_created < oldest_time){ #object is oldest so far                 oldest_time = obj$time_created                 oldest_index = i             }         }     }     #remove oldest segment     RAM$objects = RAM$objects[-oldest_index]      return(RAM) } RAM$ticks_survived = RAM$ticks_survived + 1 RAM$segments = 0 RAM$ticks_survived = 0 Snake$end_game = function(RAM){         cat('Game over! Size: ',              RAM$segments,              '. Time survived: ',              RAM$ticks_survived,              '.',          sep='')              ram.end() #stops the game } Snake$eat_apple = function(RAM){     # check for game win     if (RAM$segments > (RAM$ROM$screen.width - 2) * (RAM$ROM$screen.height - 2)){         cat('You win!')         RAM = RAM$ROM$end_game(RAM)     }      valid = FALSE #is the apple in a valid location?      #loop until the apple is in a valid (unoccupied) location     while (!valid){         valid = TRUE          #new random location         RAM$objects$apple$x = sample(2:(RAM$ROM$screen.width - 1),1)         RAM$objects$apple$y = sample(2:(RAM$ROM$screen.height - 1),1)          #overlapping anything? check all the segments again         for (i in 1:length(RAM$objects)){             obj = RAM$objects[[i]]             if (!is.null(obj$is_tail)){                 if (RAM$ROM$overlap(RAM$objects$apple,obj)) {                     #overlaps something, break out and try again with a new location                     valid = FALSE                     break                 }             }         }     }      return(RAM) }"},{"path":"https://gbkorr.github.io/rcade/articles/snake.html","id":"starting-segments","dir":"Articles","previous_headings":"9. Polish","what":"9.3 Starting Segments","title":"Snake Devlog","text":"’s nice start segments. can suppressing Snake$remove_tail() Snake$custom() desired amount segments reached, ’ll define RAM$starting_segments. RAM$starting_segments also initialized Snake$startup(). ’ve set default 10 skip boring part game.","code":"if (RAM$segments > RAM$starting_segments) RAM = RAM$ROM$remove_tail(RAM)"},{"path":"https://gbkorr.github.io/rcade/articles/snake.html","id":"difficulty-choice","dir":"Articles","previous_headings":"9. Polish","what":"9.4 Difficulty Choice","title":"Snake Devlog","text":"Snake much harder different speeds bounding regions— let’s give player choice define . can putting readline() Snake$startup, prompt player ram.init(). function go Snake$starup(), generate border Snake$make_border(). asks player want change settings default, , gives three prompts enter custom settings. ’m also changing defaults final ROM 32x16 @ 5fps. smaller ease testing. framerate: 5fps nice, mildly challenging pace, 2 gives plenty time think, 10 rather intense breakneck, especially snake gets long.","code":"Snake$set_difficulty = function(RAM){     use_defaults = readline('Use default game settings? y/n ')      if (use_defaults == 'n'){          desired_framerate = as.integer(readline(paste(             \"How FAST should the game be? \",             \"Input an integer or leave blank for default.\",             \"2: Easy\",             \"5: Default\",             \"10: Hard\",             ''             ,sep='\\n')))          desired_width = as.integer(readline(paste(             \"How WIDE should the game area be? \",             \"Input an integer or leave blank for default.\",             \"Default: 32\",             ''             ,sep='\\n')))          desired_height = as.integer(readline(paste(             \"How TALL should the game area be? \",             \"Input an integer or leave blank for default.\",             \"Default: 16\",             ''             ,sep='\\n')))          desired_segments = as.integer(readline(paste(             \"How LONG should the snake start at? \",             \"Input an integer or leave blank for default.\",             \"Default: 0\",             ''             ,sep='\\n')))          #default if blank or nonnumber         if (!is.na(desired_framerate)) RAM$ROM$framerate = desired_framerate         if (!is.na(desired_width))  RAM$ROM$screen.width = desired_width         if (!is.na(desired_height)) RAM$ROM$screen.height = desired_height         if (!is.na(desired_segments)) RAM$starting_segments = desired_segments      }      return(RAM) }"},{"path":"https://gbkorr.github.io/rcade/articles/snake.html","id":"game-demo","dir":"Articles","previous_headings":"","what":"10. Game Demo","title":"Snake Devlog","text":"’s (almost) final code Snake ROM, GIF complete game session.  can see : create RAM ram.init() start running game ram.run() pull listener session start recording inputting inputs inputs.listen()","code":"Snake = rom.init(32,16,framerate=5,sprites=list(pixel=matrix(1)))  #helper functions from before Snake$set_direction = function... Snake$move_head = function... Snake$make_border = function... Snake$spawn_segment = function... Snake$remove_tail = function... Snake$eat_apple = function... Snake$check_game_end = function... Snake$end_game = function... Snake$set_difficulty = function...  Snake$startup = function(RAM){     RAM$starting_segments = 10      #set difficulty     RAM = RAM$ROM$set_difficulty(RAM)      #make border     RAM = RAM$ROM$make_border(RAM)      #make head     RAM$objects$head = list(         x = floor(RAM$ROM$screen.width / 2),         y = floor(RAM$ROM$screen.height / 2),         spritename = 'pixel',         direction = 'neutral'     )      #make apple     RAM$objects$apple = list(         x = sample(2:(RAM$ROM$screen.width - 1),1), #random location         y = sample(2:(RAM$ROM$screen.height - 1),1),          spritename = 'pixel'     )    RAM$segments = 0   RAM$ticks_survived = 0    RAM$data = list(x = numeric(0), y = numeric(0), direction = character(0), segments = numeric(0))    return(RAM) }  Snake$custom = function(RAM){   #only do segment stuff once the snake starts moving   if (RAM$objects$head$direction != 'neutral'){     RAM = RAM$ROM$spawn_segment(RAM)      RAM$ticks_survived = RAM$ticks_survived + 1      #eat apple or remove tail     if (RAM$ROM$overlap(RAM$objects$head,RAM$objects$apple)){             RAM = RAM$ROM$eat_apple(RAM) #eat apple         }      else if (RAM$segments > RAM$starting_segments) {             RAM = RAM$ROM$remove_tail(RAM)         }             #once the starting number of segments has been reached, start removing the tail   }      #move snake   RAM = RAM$ROM$set_direction(RAM)   RAM = RAM$ROM$move_head(RAM)    #check for game end   RAM = RAM$ROM$check_game_end(RAM)    return(RAM) }   quickload(Snake)"},{"path":"https://gbkorr.github.io/rcade/articles/snake.html","id":"advanced-data-collection","dir":"Articles","previous_headings":"","what":"11. Advanced Data Collection","title":"Snake Devlog","text":"spirit R, make pretty graphs? trivial record basic data tick process game . ’ll initialize variables Snake$startup(): stick function record Snake$custom() snake starts moving. now let’s make graphs. ’ll call inside Snake$end_game(): ’s demo round played.  got 20 (84 max) segments, graphs represent data early stages game. Plot 1 (“Snake Length”) just shows many segments snake tick. Looks like ate apples pretty linear pace. Plot 2 (“Favored Directions”) shows frequently snake facing direction. spend twice much time travelling horizontally vertically; interestingly, correlates almost perfectly play region twice long tall! Plot 3 (“Turning Handedness Preference”) shows handedness every time turned— turn Left Right? Sometimes surprisingly skewed. Plot 4 (“Tile Frequency”) displays heatmap frequently snake head tile. Unsurprisingly, ’s grouped towards middle; didn’t get far enough game start hugging sides. also cool look apple spawns (correlates snake moved), think enough now.","code":"RAM$data = list(x = numeric(0), y = numeric(0), direction = character(0), segments = numeric(0)) Snake$record_data = function(RAM){     #position     RAM$data$x = c(RAM$data$x, RAM$objects$head$x)     RAM$data$y = c(RAM$data$y, RAM$objects$head$y)     #direction     RAM$data$direction = c(RAM$data$direction, RAM$objects$head$direction)     #segments     RAM$data$segments = c(RAM$data$segments, RAM$segments)          return(RAM)  } Snake$view_data = function(RAM){     if (readline(\"View graphs? y/n \") != 'y') return()          op = par(mfrow = c(1,1), mar = c(5, 4, 4, 2) + 0.1)     par(mfrow=c(2,2), mar = c(4,4,3,2) + 0.1)          data = RAM$data          #plot 1: segments over time     plot(data$segments,type='l',xlab='Time',ylab='Segments',main='Snake Length')          #plot 2: direction frequency     barplot(table(data$direction),xlab='Facing Direction',ylab='Frequency',main='Favored Directions')          #plot 3: handedness preference     handedness = list(         right = c(up='Left',down='Right'),         left = c(down='Left',up='Right'),         up = c(left='Left',right='Right'),         down = c(right='Left',left='Right')     )     hand_direction = c() #handedness direction of each turn (or NA if no turn)     for (d in 1:(length(data$direction) - 1)) hand_direction = c(hand_direction,handedness[[data$direction[d]]][data$direction[d + 1]])     hand_table = data.frame(\"direction\" = data$direction[1:(length(data$direction)-1)], \"turn\" = hand_direction)     barplot(t(table(hand_table)), beside=TRUE, main = 'Turning Handedness\\nPreference', xlab = 'Facing Direction', ylab = 'Frequency')     legend('bottomleft', title= '\\nTurn\\nDirection', legend=c('Left','Right'), fill=gray.colors(2))          #plot 4: tile frequency     tile_heatmap = matrix(0,RAM$ROM$screen.height,RAM$ROM$screen.width)     #using x and y position for each tick, get position frequencies     for (tick in 1:length(data$x)){             tile_heatmap[data$y[tick],data$x[tick]] = tile_heatmap[data$y[tick],data$x[tick]] + 1     }     tile_heatmap = tile_heatmap[2:(nrow(tile_heatmap)-1), 2:(ncol(tile_heatmap)-1)] #clip out the border     tile_heatmap = tile_heatmap[nrow(tile_heatmap):1,] #flip upside-down to match the way the game is drawn     image(1:ncol(tile_heatmap), 1:nrow(tile_heatmap), t(tile_heatmap),xlab='',ylab='',xaxt='n', yaxt='n', main= 'Tile Frequency')          par(op) #restore original settings }"},{"path":"https://gbkorr.github.io/rcade/articles/timing.html","id":"motivation","dir":"Articles","previous_headings":"","what":"1. Motivation","title":"Frame Timing","text":"One big questions making gaming device “get frames happen time, right speed?” Gaming consoles past overcome significant challenges achieve , modern computing systems conveniences make much easier. rcade uses simple robust timing system ensure game runs realtime correct speed, taking advantage base::Sys.time()’s high precision.","code":""},{"path":"https://gbkorr.github.io/rcade/articles/timing.html","id":"goal","dir":"Articles","previous_headings":"1. Motivation","what":"1.1. Goal","title":"Frame Timing","text":"first: want frame? even frame? Every 1/framerate seconds, 1/60th second 60fps (frames per second) game, want tick game (iterate physics, game logic, etc. one timestep), draw new game state. “frame” can refer lot things , try use precisely: use “frame” mean “window time want draw specific gamestate” said drawing; “tick” specific gamestate, .e. RAM updating (ticking) certain amount times. Drawing frame happen ’re within 1/60th window ; ensures game always looks like runs speed even drawing choppy. run time draw frame, can skip drawing step, want minimize . Meanwhile, ticking doesn’t actually happen specific time long lines drawing. care game drawn correct time, ’s right tick ’s drawn. ticking game usually quick, can just tick bunch catch ever falls behind current drawing window.","code":""},{"path":"https://gbkorr.github.io/rcade/articles/timing.html","id":"timing-diagram","dir":"Articles","previous_headings":"","what":"2. Timing Diagram","title":"Frame Timing","text":"’ll use diagram conceptualize timing system. ’s little weird, good job representing way timing system works.  vertical bars represent desired frames game— want game advance draw frame. , ’re spaced 1/60th second apart (60fps game). circle represents, roughly, RAM time-wise relative frames1. want “ahead” (right) current frame (white bar), far ahead.  time passes, don’t update RAM, slowly drifts left ’s behind current frame. keep ahead, update — every update RAM moves one frame ahead.  obvious thing just update every time falls behind current frame, get back ahead. ’s basically engine works!","code":""},{"path":"https://gbkorr.github.io/rcade/articles/timing.html","id":"timing-logic","dir":"Articles","previous_headings":"","what":"3. Timing Logic","title":"Frame Timing","text":"Now, also want draw game, make feel smooth, want game “” current frame— ahead white bar. logic timing game : mirrors code found ram.update(). Notably, following behavior: game can never run ahead frame game behind, repeatedly updates fast possible ’s caught ","code":"1.  if within of the current frame, sleep (wait) until the game is just behind the current frame 2.  update the RAM (advance a frame) 3.  if within of the current frame, draw the RAM 4.  repeat"},{"path":"https://gbkorr.github.io/rcade/articles/timing.html","id":"examples","dir":"Articles","previous_headings":"","what":"4. Examples:","title":"Frame Timing","text":"following diagrams demonstrate behavior engine’s response various scenarios, based purely logic defined . Note updating drawing RAM take little time, timing logic robust . Even drawing takes frame (can happen higher game resolutions), engine able deal still draw time frequently possible!","code":""},{"path":"https://gbkorr.github.io/rcade/articles/timing.html","id":"standard-loop","dir":"Articles","previous_headings":"4. Examples:","what":"4.1 Standard Loop","title":"Frame Timing","text":"game time everything working smoothly.","code":""},{"path":"https://gbkorr.github.io/rcade/articles/timing.html","id":"slightly-behind","dir":"Articles","previous_headings":"4. Examples:","what":"4.2 Slightly Behind","title":"Frame Timing","text":"RAM little behind whatever reason, quickly catches .","code":""},{"path":"https://gbkorr.github.io/rcade/articles/timing.html","id":"far-behind","dir":"Articles","previous_headings":"4. Examples:","what":"4.3 Far Behind","title":"Frame Timing","text":"RAM far behind (e.g. right rollback; see vignette(\"rollback\")), updates quickly possible catch .","code":""},{"path":"https://gbkorr.github.io/rcade/articles/timing.html","id":"frame-skipping","dir":"Articles","previous_headings":"4. Examples:","what":"4.4 Frame Skipping","title":"Frame Timing","text":"drawing RAM takes frame, engine organically skips drawing every frame () keep running drawing realtime.","code":""},{"path":"https://gbkorr.github.io/rcade/articles/timing.html","id":"notes","dir":"Articles","previous_headings":"","what":"5. Notes","title":"Frame Timing","text":"Records salient timings can found RAM$debug (see ?ram.debug) running game: RAM$debug$ahead corresponds x position (seconds) white circle diagrams end every logic cycle. RAM$debug$time.draw records time takes just draw step, ram.draw(). can helpful identifying drawing cause frameskipping, last example. RAM$debug$time.tick records time just tick step, ram.tick(). usually instant unless game runs physics system lots complex interactions uses likes chess engine.","code":""},{"path":"https://gbkorr.github.io/rcade/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Gabriel Broussard Korr. Author, maintainer.","code":""},{"path":"https://gbkorr.github.io/rcade/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Broussard Korr G (2026). rcade: Play Games RStudio. R package version 1.0.0, https://gbkorr.github.io/rcade/.","code":"@Manual{,   title = {rcade: Play Games in RStudio},   author = {Gabriel {Broussard Korr}},   year = {2026},   note = {R package version 1.0.0},   url = {https://gbkorr.github.io/rcade/}, }"},{"path":"https://gbkorr.github.io/rcade/reference/BadApple.html","id":null,"dir":"Reference","previous_headings":"","what":"Bad Apple — BadApple","title":"Bad Apple — BadApple","text":"ROM plays video Bad Apple. See vignette(\"badapple\") details.   may zoom bit cmd -. BadApple.data stores compressed video frames, decompressed BadApple$startup().","code":"RAM = ram.init(BadApple); RAM = ram.run(RAM)"},{"path":"https://gbkorr.github.io/rcade/reference/BadApple.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bad Apple — BadApple","text":"","code":"BadApple  BadApple.data"},{"path":[]},{"path":"https://gbkorr.github.io/rcade/reference/BadApple.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Bad Apple — BadApple","text":"proof concept rendering video rcade. actually easier render video reading local file, fit video come preinstalled package, compress . BadApple$startup() reconstructs video RAM initialized, saving resultant frames single animation RAM$ROM$sprites. single object loops animation constantly. frames https://github.com/Timendus/chip-8-bad-apple.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/BadApple.html","id":"compression","dir":"Reference","previous_headings":"","what":"Compression","title":"Bad Apple — BadApple","text":"BadApple.data ordered list vectors, vector corresponding frame. vector stores indices pixels flip (black <-> white) compared previous frame; allows video iteratively reconstructed losslessly starting blank frame. Much stronger forms compression devised Bad Apple projects, simple, naive approach works well enough (50 -> 1MB) application. importantly, rcade really require compressed videos since can read frames directly file.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/Snake.html","id":null,"dir":"Reference","previous_headings":"","what":"Snake Game — Snake","title":"Snake Game — Snake","text":"Plays classic game Snake. full walkthrough creation ROM can found vignette(\"snake\").","code":""},{"path":"https://gbkorr.github.io/rcade/reference/Snake.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Snake Game — Snake","text":"","code":"Snake"},{"path":"https://gbkorr.github.io/rcade/reference/Snake.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Snake Game — Snake","text":"game ROM; see vignette(\"engine\").","code":""},{"path":"https://gbkorr.github.io/rcade/reference/Snake.html","id":"how-to-play","dir":"Reference","previous_headings":"","what":"How to Play","title":"Snake Game — Snake","text":"WASD move snake. ENTER must pressed input registered. Follow steps: quickload(Snake) Follow console prompt. Open new R session load rcade library(rcade). inputs.listen() new session. Use WASD control snake. run quickload(), game ask want keep default settings input . default settings : 5 frames per second32x16 bounding area10 starting snake length","code":""},{"path":"https://gbkorr.github.io/rcade/reference/fonts.3x3.html","id":null,"dir":"Reference","previous_headings":"","what":"3x3 Font — fonts.3x3","title":"3x3 Font — fonts.3x3","text":"Basic font lowercase. Readability poor, produces compact text possible. Use render.text().","code":""},{"path":"https://gbkorr.github.io/rcade/reference/fonts.3x3.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"3x3 Font — fonts.3x3","text":"","code":"fonts.3x3"},{"path":"https://gbkorr.github.io/rcade/reference/fonts.3x3.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"3x3 Font — fonts.3x3","text":"font; list containing font-related properties list sprites character.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/fonts.3x5.html","id":null,"dir":"Reference","previous_headings":"","what":"3x5 Font — fonts.3x5","title":"3x5 Font — fonts.3x5","text":"Basic font common characters. Horizontally compact, much readable fonts.3x3. preferred low-res font situations. Made truly. sprites pretty snazzy. Use render.text().","code":""},{"path":"https://gbkorr.github.io/rcade/reference/fonts.3x5.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"3x5 Font — fonts.3x5","text":"","code":"fonts.3x5"},{"path":"https://gbkorr.github.io/rcade/reference/fonts.3x5.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"3x5 Font — fonts.3x5","text":"font; list containing font-related properties list sprites character.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/inputs.command.html","id":null,"dir":"Reference","previous_headings":"","what":"Ingame Commands — inputs.command","title":"Ingame Commands — inputs.command","text":"Allow user interact RAM listening session inputting /[command] listening. See vignette(\"rrio\") see action.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/inputs.command.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ingame Commands — inputs.command","text":"","code":"inputs.command(RAM, command)"},{"path":"https://gbkorr.github.io/rcade/reference/inputs.command.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ingame Commands — inputs.command","text":"RAM RAM object. command Command use; parsed inputs.csv.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/inputs.command.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Ingame Commands — inputs.command","text":"commands generally useful debugging testing parts game difficult test full speed. Alternatively, greater control can achieved using display session manually interacting game :   also allows user copy restore RAMs savestates, etc.","code":"RAM = ram.input(RAM, [input]) RAM = ram.tick(RAM) render.ram(RAM)"},{"path":"https://gbkorr.github.io/rcade/reference/inputs.command.html","id":"commands","dir":"Reference","previous_headings":"","what":"Commands","title":"Ingame Commands — inputs.command","text":"game paused input entered, processed next /tick game resumes. allows player play game frame--frame.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/inputs.convert.html","id":null,"dir":"Reference","previous_headings":"","what":"Read Inputs with RAM — inputs.convert","title":"Read Inputs with RAM — inputs.convert","text":"Retrieves new inputs inputs.read(), converts timestamp tick game process , saves RAM$inputs. new inputs occurred prior tick, rolls back resolve dropped input. See vignette(\"inputs\") details.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/inputs.convert.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read Inputs with RAM — inputs.convert","text":"","code":"inputs.convert(RAM)"},{"path":"https://gbkorr.github.io/rcade/reference/inputs.convert.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read Inputs with RAM — inputs.convert","text":"RAM RAM object update.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/inputs.convert.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Read Inputs with RAM — inputs.convert","text":"New inputs inputs exist inputs.csv RAM$inputs. tick input occur calculated :   RAM$began stores c(timestamp, tick) last time ram.run() called, ROM$input_delay desired delay inputting key game register , ROM$framerate desired framerate game. New inputs occurring last call ram.run, .e. game started game paused, tick set -1 never registered. RAM$inputs updated contain new inputs, matching inputs.csv.","code":"RAM$began[2] + ceiling(     RAM$ROM$framerate * (             newinputs$timestamp +             RAM$ROM$input_delay -             RAM$began[1]     ) )"},{"path":"https://gbkorr.github.io/rcade/reference/inputs.listen.html","id":null,"dir":"Reference","previous_headings":"","what":"Record Player Inputs — inputs.listen","title":"Record Player Inputs — inputs.listen","text":"inputs.listen() listens input writes entered text inputs.csv file package directory. inputs.listen() run separate RStudio instance game running. allows game read player input without interruption. inputs.read() reads inputs.csv file; called main gameloop retrieve live player input. input submitted Enter key pressed. can make interacting game initially challenging.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/inputs.listen.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Record Player Inputs — inputs.listen","text":"","code":"inputs.listen()  inputs.read()"},{"path":"https://gbkorr.github.io/rcade/reference/inputs.listen.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Record Player Inputs — inputs.listen","text":"'input' string text timestamp corresponding game process input. Inputs stored rows inputs.csv dataframe, following columns: inputs.listen() adds new row inputs.csv time Enter pressed.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/inputs.listen.html","id":"inputs-csv","dir":"Reference","previous_headings":"","what":"inputs.csv","title":"Record Player Inputs — inputs.listen","text":"inputs.csv stored tools::R_user_dir('rcade'), directory storing package data. one inputs.csv file exists read package; file wiped every time ram.init() called.","code":""},{"path":[]},{"path":"https://gbkorr.github.io/rcade/reference/inputs.process.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply Inputs — inputs.process","title":"Apply Inputs — inputs.process","text":"Updates RAM$actions according inputs occurring current frame. Inputs actions stored RAM like :","code":""},{"path":"https://gbkorr.github.io/rcade/reference/inputs.process.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply Inputs — inputs.process","text":"","code":"inputs.process(RAM)"},{"path":"https://gbkorr.github.io/rcade/reference/inputs.process.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply Inputs — inputs.process","text":"RAM RAM object update.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/inputs.process.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Apply Inputs — inputs.process","text":"following outline process player entering input registered game. Player types \"wa\" inputs.listen() listener. Player presses Enter; input created consisting string \"wa\" timestamp (see inputs.listen). input written inputs.csv. gameloop runs inputs.convert(), input added RAM$inputs timestamp converted tick processed . RAM$ticks == tick timestamp input RAM$inputs, input processed: input split individual characters: \"w\" \"\". actions corresponding keys, RAM$ROM$keybinds[\"w\"] RAM$ROM$keybinds[\"\"], set TRUE RAM$actions (see ). Game code RAM$ROM$custom() reads RAM$actions move player character accordingly. next frame, RAM$actions set FALSE inputs checked .","code":""},{"path":"https://gbkorr.github.io/rcade/reference/inputs.process.html","id":"keybinds","dir":"Reference","previous_headings":"","what":"Keybinds","title":"Apply Inputs — inputs.process","text":"Keybinds set dev , e.g.   stores actions ('attack', '', etc.) keys (k, w, etc.) , input, activate actions. keybinds populate RAM$actions RAM initialized:   key registered, corresponding action RAM$actions set TRUE one frame. game read RAM$actions control game behavior; see vignette('rrio') see action.","code":"ROM$keybinds = c(k = 'attack', w = 'up', a = 'left', s = 'down', d = 'right') RAM$actions = c(attack = FALSE, up = FALSE, left = FALSE, down = FALSE. right = FALSE)"},{"path":"https://gbkorr.github.io/rcade/reference/quickload.html","id":null,"dir":"Reference","previous_headings":"","what":"Play a Game — quickload","title":"Play a Game — quickload","text":"Starts game immediately using ROM.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/quickload.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Play a Game — quickload","text":"","code":"quickload(ROM)"},{"path":"https://gbkorr.github.io/rcade/reference/quickload.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Play a Game — quickload","text":"ROM ROM play.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/quickload.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Play a Game — quickload","text":"Convenience wrapper code:   saves RAM environment quickload() called, RAM can accessed afterwards run manually.","code":"RAM = ram.init(ROM) RAM = ram.run(RAM)"},{"path":"https://gbkorr.github.io/rcade/reference/quickload.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Play a Game — quickload","text":"","code":"quickload(Snake) #> Error in quickload(Snake): could not find function \"quickload\""},{"path":"https://gbkorr.github.io/rcade/reference/ram.backup.html","id":null,"dir":"Reference","previous_headings":"","what":"Backup RAM — ram.backup","title":"Backup RAM — ram.backup","text":"Creates backup RAM. different full copy (e.g. my_copy = RAM):","code":""},{"path":"https://gbkorr.github.io/rcade/reference/ram.backup.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Backup RAM — ram.backup","text":"","code":"ram.backup(RAM)"},{"path":"https://gbkorr.github.io/rcade/reference/ram.backup.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Backup RAM — ram.backup","text":"RAM RAM object.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/ram.backup.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Backup RAM — ram.backup","text":"RAM, minus $ROM, $inputs, $debug, $intermediate, $backup, $paused. output stored main RAM's $intermediate $backup.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/ram.backup.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Backup RAM — ram.backup","text":"game uses periodically back gamestate can restore rollback.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/ram.debug.html","id":null,"dir":"Reference","previous_headings":"","what":"Game Debug Info — ram.debug","title":"Game Debug Info — ram.debug","text":"NEED ACTUALLY WRITE FUNCTION (print details debug, e.g. riollback frequency, average times, et.c) function prints , recommended plot separately (see examples).","code":""},{"path":"https://gbkorr.github.io/rcade/reference/ram.debug.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Game Debug Info — ram.debug","text":"","code":"ram.debug(RAM)"},{"path":"https://gbkorr.github.io/rcade/reference/ram.debug.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Game Debug Info — ram.debug","text":"RAM RAM object.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/ram.debug.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Game Debug Info — ram.debug","text":"function prints timing-related debug information. RAM$debug contains host data RAM's recent gameplay, relevant timing rollback systems (vignette(\"timing\") vignette(\"rollback\")). mostly useful internal debugging (.e. package dev), especially online play.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/ram.debug.html","id":"ram-debug","dir":"Reference","previous_headings":"","what":"RAM$debug","title":"Game Debug Info — ram.debug","text":"RAM$debug contains following elements:","code":""},{"path":"https://gbkorr.github.io/rcade/reference/ram.debug.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Game Debug Info — ram.debug","text":"","code":"if (FALSE) { # \\dontrun{ #plot buffer over time to see rollbacks plot(RAM$debug$time, RAM$debug$buffer, type='l')  #compare which parts of each frame took up the most time plot(rowSums(cbind(   RAM$debug$time.tick,   RAM$debug$time.inputs,   RAM$debug$time.draw ),na.rm=TRUE), type='l') lines(RAM$debug$time.tick, col='blue') lines(RAM$debug$time.draw, col='red') lines(RAM$debug$time.inputs, col='green') } # }"},{"path":"https://gbkorr.github.io/rcade/reference/ram.end.html","id":null,"dir":"Reference","previous_headings":"","what":"Stop the Gameloop — ram.end","title":"Stop the Gameloop — ram.end","text":"Exits ram.run() without printing error traceback; code equivalent ^C.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/ram.end.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Stop the Gameloop — ram.end","text":"","code":"ram.end()"},{"path":"https://gbkorr.github.io/rcade/reference/ram.end.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Stop the Gameloop — ram.end","text":"Useful Game scenarios, etc; see usage vignette(\"snake\").","code":""},{"path":"https://gbkorr.github.io/rcade/reference/ram.init.html","id":null,"dir":"Reference","previous_headings":"","what":"Create RAM Object — ram.init","title":"Create RAM Object — ram.init","text":"Uses game ROM object create RAM object, stores dynamic data game. ram.run() runs game, RAM updated read.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/ram.init.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create RAM Object — ram.init","text":"","code":"ram.init(ROM)"},{"path":"https://gbkorr.github.io/rcade/reference/ram.init.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create RAM Object — ram.init","text":"ROM ROM object containing game code.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/ram.init.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create RAM Object — ram.init","text":"RAM object contains following elements.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/ram.init.html","id":"notes","dir":"Reference","previous_headings":"","what":"Notes","title":"Create RAM Object — ram.init","text":"Custom game code (RAM$ROM$custom) typically modify RAM$objects. makes inspecting handling RAM consistent across games.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/ram.input.html","id":null,"dir":"Reference","previous_headings":"","what":"Manually Add an Input to RAM — ram.input","title":"Manually Add an Input to RAM — ram.input","text":"Allows user input RAM RAM run.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/ram.input.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Manually Add an Input to RAM — ram.input","text":"","code":"ram.input(RAM, input, timestamp = NULL)"},{"path":"https://gbkorr.github.io/rcade/reference/ram.input.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Manually Add an Input to RAM — ram.input","text":"RAM RAM object. input Input add RAM$inputs. Exactly might type input session. timestamp Specific tick set input . NULL sets input processed next tick.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/ram.input.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Manually Add an Input to RAM — ram.input","text":"Adds input RAM$inputs new input inputs.csv. input set occur next tick unless specified timestamp.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/ram.new_object.html","id":null,"dir":"Reference","previous_headings":"","what":"Add an Unnamed Object to RAM$objects — ram.new_object","title":"Add an Unnamed Object to RAM$objects — ram.new_object","text":"Puts object RAM$objects without assigning name. useful iteratively creating objects referenced name— see Snake vignette example . Otherwise, objects put RAM$objects like easy reference:","code":"RAM$objects$my_object = list(...) print(RAM$objects$my_object)"},{"path":"https://gbkorr.github.io/rcade/reference/ram.new_object.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add an Unnamed Object to RAM$objects — ram.new_object","text":"","code":"ram.new_object(RAM, object)"},{"path":"https://gbkorr.github.io/rcade/reference/ram.new_object.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add an Unnamed Object to RAM$objects — ram.new_object","text":"RAM RAM object. object Game object; list properties like $x $spritename.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/ram.new_object.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add an Unnamed Object to RAM$objects — ram.new_object","text":"Convenience function RAM$objects = c(RAM$objects, list(object)). syntax adding nested list list c(listA, list(listB))! Nested lists R can confusing, better function automatically trust users remember correct syntax.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/ram.resume.html","id":null,"dir":"Reference","previous_headings":"","what":"Resume Live Gameloop — ram.resume","title":"Resume Live Gameloop — ram.resume","text":"RAM needs several things set every time gameloop starts: RAM$time needs set current time.sec() gameloop's timing work properly (see vignette(\"timing\")). RAM$began set c(time.sec(), RAM$ticks) inputs converted correct frame processing (inputs.convert; see also vignette(\"inputs\"))","code":""},{"path":"https://gbkorr.github.io/rcade/reference/ram.resume.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Resume Live Gameloop — ram.resume","text":"","code":"ram.resume(RAM, start_at = NULL)"},{"path":"https://gbkorr.github.io/rcade/reference/ram.resume.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Resume Live Gameloop — ram.resume","text":"RAM RAM object. start_at Optional parameter set exact time.sec() RAM start gameloop; may useful syncing online play.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/ram.rollback.html","id":null,"dir":"Reference","previous_headings":"","what":"Execute a Rollback — ram.rollback","title":"Execute a Rollback — ram.rollback","text":"Restores RAM state several seconds ago. ram.update() rapidly advance game catch current time. usually triggered inputs.read() upon registering input supposed happened, received late. prevent input dropped, game rolls back reruns past seconds rectify mistake.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/ram.rollback.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Execute a Rollback — ram.rollback","text":"","code":"ram.rollback(RAM)"},{"path":"https://gbkorr.github.io/rcade/reference/ram.rollback.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Execute a Rollback — ram.rollback","text":"RAM RAM object.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/ram.rollback.html","id":"backups","dir":"Reference","previous_headings":"","what":"Backups","title":"Execute a Rollback — ram.rollback","text":"RAM always keeps backup saved RAM$backup, containing entire RAM time backup minus inputs, debug info, ROM; never rolled back. Backups minimum age RAM$ROM$backup_duration; RAM can restored around time ago. Backups saved ram.tick(). RAM$intermediate used store next backup replaces current one, ensure backups never younger RAM$ROM$backup_duration.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/ram.rollback.html","id":"rollback","dir":"Reference","previous_headings":"","what":"Rollback","title":"Execute a Rollback — ram.rollback","text":"function just restores RAM$backup   Since puts RAM$time behind, gameloop automatically speeds catch RAM back . catchup process runs inputs , inputs received late, now registered time.","code":"RAM = utils::modifyList(RAM, RAM$backup)"},{"path":"https://gbkorr.github.io/rcade/reference/ram.run.html","id":null,"dir":"Reference","previous_headings":"","what":"Main Gameloop — ram.run","title":"Main Gameloop — ram.run","text":"ram.run() runs main gameloop, continuously ticking drawing. game can paused ^C, resume ram.run() called .","code":""},{"path":"https://gbkorr.github.io/rcade/reference/ram.run.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Main Gameloop — ram.run","text":"","code":"ram.run(RAM, start_at = NULL)"},{"path":"https://gbkorr.github.io/rcade/reference/ram.run.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Main Gameloop — ram.run","text":"RAM RAM object run. start_at RAM wait time.sec()== value start running. NULL, RAM starts running immediately. argument used sync multiplayer sessions otherwise matter.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/ram.run.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Main Gameloop — ram.run","text":"function runs following code returns RAM upon interruption ^C error.   function also print full traceback encounters error.","code":"while(TRUE) RAM = ram.update(RAM)"},{"path":"https://gbkorr.github.io/rcade/reference/ram.run.html","id":"function-tree","dir":"Reference","previous_headings":"","what":"Function Tree","title":"Main Gameloop — ram.run","text":"Functions nested gameloop like : ram.run()\tram.update() every frame (see vignette(\"timing\"))\t\tinputs.convert()\t\t\tinputs.read()\t\t\tinputs.command() commands sent\t\tinputs.process()\t\tram.tick()\t\t\tRAM$ROM$custom()\t\trender.ram() RAM$time > time.sec()\t\t\trender.object() every object RAM$objects\t\t\t\trender.sprite() custom obj$draw()\t\t\t\t  render.overlay()\t\t\trender.scene()\t\t\t\trender.overlay() every layer scene$layers\t\t\trender.matrix()","code":""},{"path":"https://gbkorr.github.io/rcade/reference/ram.set_rng.html","id":null,"dir":"Reference","previous_headings":"","what":"Set RAM RNG — ram.set_rng","title":"Set RAM RNG — ram.set_rng","text":"Sets RAM's RNG base::set.seed(). useful ROM$startup dev wants game always use RNG seed, etc.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/ram.set_rng.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set RAM RNG — ram.set_rng","text":"","code":"ram.set_rng(RAM, seed)"},{"path":"https://gbkorr.github.io/rcade/reference/ram.set_rng.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set RAM RNG — ram.set_rng","text":"RAM RAM object. seed Integer used base::set.seed.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/ram.set_rng.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Set RAM RNG — ram.set_rng","text":"R's RNG based .Random.seed global variable, updates random call set.seed() called. RAM stores copy variable temporarily restores running game code. Thus RNG ends working expected within game, produce random calls game rolls back. Additionally, RAM restores R session's RNG running game code, user's R environment unaffected random calls game.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/ram.tick.html","id":null,"dir":"Reference","previous_headings":"","what":"Tickstep RAM — ram.tick","title":"Tickstep RAM — ram.tick","text":"Runs one tick (frame) RAM. means calling RAM$ROM$custom() (see rom.init).","code":""},{"path":"https://gbkorr.github.io/rcade/reference/ram.tick.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tickstep RAM — ram.tick","text":"","code":"ram.tick(RAM)"},{"path":"https://gbkorr.github.io/rcade/reference/ram.tick.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tickstep RAM — ram.tick","text":"RAM RAM object update.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/ram.tick.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tickstep RAM — ram.tick","text":"following happens RAM object: RAM$ticks increases one. (new tick occurred) RAM$time increases 1/framerate. (RAM now one frame time) RAM = RAM$ROM$custom(RAM) run. (game code run RAM) RAM$backup occasionally updated; see ram.rollback. (game occasionally backed )","code":""},{"path":"https://gbkorr.github.io/rcade/reference/ram.update.html","id":null,"dir":"Reference","previous_headings":"","what":"Gameloop — ram.update","title":"Gameloop — ram.update","text":"Ticks RAM, draws RAM, syncs time framerate. function looped infinitely ram.run(); used alone.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/ram.update.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Gameloop — ram.update","text":"","code":"ram.update(RAM)"},{"path":"https://gbkorr.github.io/rcade/reference/ram.update.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Gameloop — ram.update","text":"RAM RAM object update.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/ram.update.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Gameloop — ram.update","text":"RAM behind current frame (lagging) (RAM%time < time.sec()): drawing skipped ram.update() called delay RAM ahead current frame (caught ): render.ram() called draw game game sleeps next frame tries keep RAM current frame, always ahead (time draw). RAM behind current frame, game update process speeds runs game fast possible without drawing get back current time. Since drawing far slowest part gameloop, allows recover catch present quickly time rewound rollback.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/render.animate.html","id":null,"dir":"Reference","previous_headings":"","what":"Sprite Animations — render.animate","title":"Sprite Animations — render.animate","text":"Retrieves current frame sprite animation. todo examples","code":""},{"path":"https://gbkorr.github.io/rcade/reference/render.animate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sprite Animations — render.animate","text":"","code":"render.animate(spritename, timer, sprites, render_framerate = 60)"},{"path":"https://gbkorr.github.io/rcade/reference/render.animate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sprite Animations — render.animate","text":"spritename String; name sprite defined sprites. timer Number ticks elapsed since animation started. sprites RAM$ROM$sprites; list sprites. render_framerate RAM$ROM$framerate; game framerate.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/render.animate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sprite Animations — render.animate","text":"Returns sprite matrix suitable render.sprite().","code":""},{"path":"https://gbkorr.github.io/rcade/reference/render.animate.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Sprite Animations — render.animate","text":"sprite defined ROM$sprites can either simple complex; Simple sprites just static sprite matrix. Complex sprites list containing multiple frames animation. Complex sprites can following properties: Animated sprites can tested using render.test_animation().","code":""},{"path":"https://gbkorr.github.io/rcade/reference/render.animate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sprite Animations — render.animate","text":"","code":"#simple two-part animation using sprite$next_animation"},{"path":"https://gbkorr.github.io/rcade/reference/render.makefont.html","id":null,"dir":"Reference","previous_headings":"","what":"Fonts — render.makefont","title":"Fonts — render.makefont","text":"Fonts used draw text ingame render.text(). font list including $sprites, list sprites character supported font. really try/consider adding random demo photos vignettes: (esp. inputs render) way dense. even render replace console examples images fonts monospaced.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/render.makefont.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fonts — render.makefont","text":"","code":"render.makefont(char_group = \"uppercase\", width, txt)"},{"path":"https://gbkorr.github.io/rcade/reference/render.makefont.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fonts — render.makefont","text":"char_group Character group make sprites ; see . width Desired width character. txt String turn fonts. nonspace characters converted 1 sprites.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/render.makefont.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fonts — render.makefont","text":"Fonts can following metadata:","code":""},{"path":"https://gbkorr.github.io/rcade/reference/render.makefont.html","id":"render-makefont-","dir":"Reference","previous_headings":"","what":"render.makefont()","title":"Fonts — render.makefont","text":"render.makefont() convenient extension render.makesprite() create batches characters . use , enter string characters char_group lined horizontally (see examples). function create full font object; just generates $sprites. function returns list sprite set character. sprites' widths must set width, height determined number newlines txt like render.makesprite(). char_groups follows: Missing characters replaced empty sprites appropriate size.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/render.makefont.html","id":"preinstalled-fonts","dir":"Reference","previous_headings":"","what":"Preinstalled Fonts","title":"Fonts — render.makefont","text":"package comes two fonts: fonts.3x3 detailed fonts.3x5.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/render.makefont.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fonts — render.makefont","text":"","code":"#used for `fonts.3x3`: example_font = list(   width = 3,   height = 3,   sprites = render.makefont('uppercase',width=3,'  o  oo  ooo oo  ooo ooo  o  o o ooo ooo o o o   o o ooo ooo ooo  o  ooo  oo ooo o o o o o o o o o o oo ooo ooo o   o o oo  oo  o   ooo  o   o  oo  o   ooo o o o o ooo o o oo   o   o  o o o o ooo  o   o   o o o ooo ooo oo  ooo o   ooo o o ooo oo  o o ooo ooo o o ooo o    oo o o oo   o  ooo  o  ooo o o  o   oo ') ) #> Error in render.makefont(\"uppercase\", width = 3, \"\\n o  oo  ooo oo  ooo ooo  o  o o ooo ooo o o o   o o ooo ooo ooo  o  ooo  oo ooo o o o o o o o o o o oo\\nooo ooo o   o o oo  oo  o   ooo  o   o  oo  o   ooo o o o o ooo o o oo   o   o  o o o o ooo  o   o   o\\no o ooo ooo oo  ooo o   ooo o o ooo oo  o o ooo ooo o o ooo o    oo o o oo   o  ooo  o  ooo o o  o   oo\\n\"): could not find function \"render.makefont\"  render.matrix(cbind(   example_font$sprites$H,   matrix(0,3,1),   example_font$sprites$I )) #> Error in render.matrix(cbind(example_font$sprites$H, matrix(0, 3, 1),     example_font$sprites$I)): could not find function \"render.matrix\""},{"path":"https://gbkorr.github.io/rcade/reference/render.makesprite.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Sprite Matrix from Text — render.makesprite","title":"Generate Sprite Matrix from Text — render.makesprite","text":"engine needs sprites matrix numbers, inconvenient hand. function converts string sprite allow dev easily create sprites. default, non-space characters inputted converted 1 (black) pixels sprite, space characters 0 (transparent).","code":""},{"path":"https://gbkorr.github.io/rcade/reference/render.makesprite.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Sprite Matrix from Text — render.makesprite","text":"","code":"render.makesprite(   txt,   width = NULL,   default = 1,   lookup = c(` ` = 0, . = 0, `_` = 2) )"},{"path":"https://gbkorr.github.io/rcade/reference/render.makesprite.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Sprite Matrix from Text — render.makesprite","text":"txt String convert matrix. width Sprite width. usually set automatically. default Number characters lookup converted. lookup Table converting characters non-default numbers.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/render.makesprite.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Sprite Matrix from Text — render.makesprite","text":"Returns sprite matrix suitable render.matrix().","code":""},{"path":"https://gbkorr.github.io/rcade/reference/render.makesprite.html","id":"defaults","dir":"Reference","previous_headings":"","what":"Defaults","title":"Generate Sprite Matrix from Text — render.makesprite","text":"height sprite matrix equal number newlines txt, one might expect. width determined rightmost non-space character, unless set manually. Characters txt converted 1-1 numbers defined default lookup. default character conversion :","code":""},{"path":"https://gbkorr.github.io/rcade/reference/render.makesprite.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Sprite Matrix from Text — render.makesprite","text":"","code":"smiley = render.makesprite('   o o   o o o     o  ooooo ') #> Error in render.makesprite(\"\\n  o o\\n  o o\\no     o\\n ooooo\\n\"): could not find function \"render.makesprite\"  render.matrix(smiley) #> Error in render.matrix(smiley): could not find function \"render.matrix\"  #multicolor palette = badger = render.makesprite('   O O =     =  HHHHH ', lookup = c(' ' = 0, 'O' = 1, '=' = 2, 'H' = 3)) #> Error in render.makesprite(\"\\n  O O\\n=     =\\n HHHHH\\n\", lookup = c(` ` = 0,     O = 1, `=` = 2, H = 3)): could not find function \"render.makesprite\"  print(badger) #> Error: object 'badger' not found render.matrix(badger, palette = c(' ', 'O', 'H', '=')) #> Error in render.matrix(badger, palette = c(\" \", \"O\", \"H\", \"=\")): could not find function \"render.matrix\""},{"path":"https://gbkorr.github.io/rcade/reference/render.matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Render a Matrix to the Console — render.matrix","title":"Render a Matrix to the Console — render.matrix","text":"Prints matrix pixels: characters coded matrix. default, prints black&white black pixels represented []:","code":"[]   []  [] []      []   [][][]"},{"path":"https://gbkorr.github.io/rcade/reference/render.matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Render a Matrix to the Console — render.matrix","text":"","code":"render.matrix(M, clear_console = FALSE, palette = c(\"  \", \"[]\", \"  \"))"},{"path":"https://gbkorr.github.io/rcade/reference/render.matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Render a Matrix to the Console — render.matrix","text":"M Matrix drawn. contain nonegative integers, corresponding desired characters drawn defined palette. clear_console Wipes console cat('\\f') printing. keeps render consistent position. palette ordered vector character draw element M = 0, 1, 2, 3, 4, etc.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/render.matrix.html","id":"default-palette","dir":"Reference","previous_headings":"","what":"Default Palette","title":"Render a Matrix to the Console — render.matrix","text":"default matrix--character encoding (palette) follows: 0:    : transparent1: [] : black2:    : white White Transparent usually printed identically, behavior differs elsewhere package. (.e. matrices overlaid render.overlay())","code":""},{"path":"https://gbkorr.github.io/rcade/reference/render.matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Render a Matrix to the Console — render.matrix","text":"","code":"smiley = matrix(c(0,0,1,0,0,0,0,1,1,1,0,1,0,0,0,1,1,1,0,1,0,0,0,1,0,0,1,0), ncol = 7) print(smiley) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] #> [1,]    0    0    1    0    1    0    0 #> [2,]    0    0    1    0    1    0    0 #> [3,]    1    0    0    0    0    0    1 #> [4,]    0    1    1    1    1    1    0 render.matrix(smiley) #> Error in render.matrix(smiley): could not find function \"render.matrix\"  #ASCII art badger = matrix(c(0,3,0,0,0,2,1,0,2,0,0,2,1,0,2,0,0,2,0,3,0), ncol = 7) render.matrix(badger, palette = c(' ', 'O', 'H', '=')) #> Error in render.matrix(badger, palette = c(\" \", \"O\", \"H\", \"=\")): could not find function \"render.matrix\""},{"path":"https://gbkorr.github.io/rcade/reference/render.object.html","id":null,"dir":"Reference","previous_headings":"","what":"Draw an Object to the Scene — render.object","title":"Draw an Object to the Scene — render.object","text":"Calls render.sprite() using object's $spritename (name desired sprite RAM$ROM$sprites). object drawn position (obj$x, obj$y) layer obj$layer specified (see ). Objects $spritename drawn, unless custom drawing behavior defined obj$draw(): object function set obj$draw(), run instead render.sprite(). allows game dev create custom drawing behavior.","code":"scene = obj$draw(scene, obj, RAM)"},{"path":"https://gbkorr.github.io/rcade/reference/render.object.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Draw an Object to the Scene — render.object","text":"","code":"render.object(scene, obj, RAM)"},{"path":"https://gbkorr.github.io/rcade/reference/render.object.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Draw an Object to the Scene — render.object","text":"scene Scene object. obj Object RAM$objects. Objects $spritename drawn. RAM RAM object.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/render.object.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Draw an Object to the Scene — render.object","text":"Returns scene object sprite drawn. function called render.ram() object RAM$objects.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/render.object.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Draw an Object to the Scene — render.object","text":"object needs $spritename drawn. Objects can also following properties influence drawn: otherwise, default value (second column) used.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/render.overlay.html","id":null,"dir":"Reference","previous_headings":"","what":"Overlay Two Matrices — render.overlay","title":"Overlay Two Matrices — render.overlay","text":"function overlays two sprites, respecting transparency (values 0). Specifically, sprite placed top background, position can altered specifying x y. new background sprite atop returned; part sprite outside bounds ignored.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/render.overlay.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Overlay Two Matrices — render.overlay","text":"","code":"render.overlay(background, sprite, x = 1, y = 1, invert = FALSE)"},{"path":"https://gbkorr.github.io/rcade/reference/render.overlay.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Overlay Two Matrices — render.overlay","text":"background sprite; matrix nonnegative integers corresponding pixels small image; see render.matrix(). sprite Another sprite overlay background. x X coordinate sprite drawn scene. Specifically, determines position top-left pixel sprite. y Y coordinate purpose. invert Whether background colors inverted; see .","code":""},{"path":"https://gbkorr.github.io/rcade/reference/render.overlay.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Overlay Two Matrices — render.overlay","text":"Returns background sprite drawn .","code":""},{"path":"https://gbkorr.github.io/rcade/reference/render.overlay.html","id":"inversion","dir":"Reference","previous_headings":"","what":"Inversion","title":"Overlay Two Matrices — render.overlay","text":"Non-FALSE values invert invert colors background sprite opaque (nonzero). invert TRUE, background assumed monochrome values 1 2 (black white) swapped. invert vector values, used ordered lookup invert values 0, 1, 2, 3, etc. background. example, c(1,2,1) change 0->1, 1->2, 2->1 throw error background contains value higher 2. mainly provide functionality multicolor systems, function know invert arbitrary values.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/render.overlay.html","id":"conceptual-usage","dir":"Reference","previous_headings":"","what":"Conceptual Usage","title":"Overlay Two Matrices — render.overlay","text":"NOTE: function clip part sprite falls bounds background; examples, boxes padded extra space.     hate examples","code":"= 0 (transparent) [] = 1 (black) .  = 2 (white)   [][][][][]                    [][][][][] []. . . []                    []. . . [] []. . . []     [][][][][]     []. [][][][][] []. . . []  +  []. . . []  =  []. []. . . [] [][][][][]     []. . . []     [][][]. . . []                []. . . []         []. . . []                [][][][][]         [][][][][]  Transparency:  [][][][][]                    [][][][][] []      []                    []      [] []      []     [][][][][]     []  [][][][][] []      []  +  []      []  =  []  []  []  [] [][][][][]     []      []     [][][][][]  []                []      []         []      []                [][][][][]         [][][][][]  Inversion:  [][][][][]. .                     [][][][][]. . [][][][][]. .                     [][][][][]. . [][][][][]. .      [][][][][]     [][]. . . [][] [][][][][]. .   ~  [][][][][]  =  [][]. . . [][] [][][][][]. .      [][][][][]     [][]. . . [][] . . . . . . .      [][][][][]     . . [][][][][] . . . . . . .      [][][][][]     . . [][][][][] print('wow') #> [1] \"wow\""},{"path":"https://gbkorr.github.io/rcade/reference/render.overlay.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Overlay Two Matrices — render.overlay","text":"","code":"bg = matrix(2,7,7)  box = matrix(1,5,5) box.white = box; box.white[2:4,2:4] = 2 box.transparent = box; box.transparent[2:4,2:4] = 0  #using pipes for conciseness; see ?pipeOp #example 1 bg |>   render.overlay(box.white) |>   render.overlay(box.white, 3, 3) |>   render.matrix() #> Error in render.matrix(render.overlay(render.overlay(bg, box.white), box.white,     3, 3)): could not find function \"render.matrix\"  #transparency bg |>   render.overlay(box.transparent) |>   render.overlay(box.transparent, 3, 3) |>   render.matrix() #> Error in render.matrix(render.overlay(render.overlay(bg, box.transparent),     box.transparent, 3, 3)): could not find function \"render.matrix\"  #inversion bg |>   render.overlay(box) |>   render.overlay(box, 3, 3, invert=TRUE) |>   render.matrix() #> Error in render.matrix(render.overlay(render.overlay(bg, box), box, 3,     3, invert = TRUE)): could not find function \"render.matrix\""},{"path":"https://gbkorr.github.io/rcade/reference/render.ram.html","id":null,"dir":"Reference","previous_headings":"","what":"Draw the RAM — render.ram","title":"Draw the RAM — render.ram","text":"Draws RAM current tick drawing object RAM$objects sprite.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/render.ram.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Draw the RAM — render.ram","text":"","code":"render.ram(RAM, clear_console = FALSE)"},{"path":"https://gbkorr.github.io/rcade/reference/render.ram.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Draw the RAM — render.ram","text":"RAM RAM object draw. clear_console console wiped rendering scene? keeps render consistent position.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/render.ram.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Draw the RAM — render.ram","text":"creates scene object size (RAM$ROM$screen.width, RAM$ROM$screen.height), calls render.object() every object draw onto scene, calls render.scene().","code":""},{"path":"https://gbkorr.github.io/rcade/reference/render.scene.html","id":null,"dir":"Reference","previous_headings":"","what":"Render Scene to Console — render.scene","title":"Render Scene to Console — render.scene","text":"Renders scene object console stacking layers. layer matrix drawable render.matrix(), layers iteratively stacked render.overlay(). highest layer drawn top.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/render.scene.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Render Scene to Console — render.scene","text":"","code":"render.scene(scene, clear_console = FALSE, palette = c(\"  \", \"[]\", \"  \"))"},{"path":"https://gbkorr.github.io/rcade/reference/render.scene.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Render Scene to Console — render.scene","text":"scene Scene object rendered; see . clear_console console wiped rendering scene? keeps render consistent position. palette ordered vector character draw element M = 0, 1, 2, 3, 4, etc. Typically ROM$palette, default.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/render.scene.html","id":"scene","dir":"Reference","previous_headings":"","what":"Scene","title":"Render Scene to Console — render.scene","text":"scene object following properties:","code":""},{"path":"https://gbkorr.github.io/rcade/reference/render.scene.html","id":"inversion","dir":"Reference","previous_headings":"","what":"Inversion","title":"Render Scene to Console — render.scene","text":"scene also scene$layers$invert layer; anything drawn (e.g. render.sprite(...layer = 'invert')) invert colors rendered scene. useful text.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/render.scene.html","id":"see-also","dir":"Reference","previous_headings":"","what":"See Also","title":"Render Scene to Console — render.scene","text":"render sprite onto scene layer, render.sprite() render object onto scene, render.object() gameloop creates renders scene render.ram()","code":""},{"path":"https://gbkorr.github.io/rcade/reference/render.scene.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Render Scene to Console — render.scene","text":"","code":"#basic layering scene = list(width=16, height=16) box = matrix(c(1,1,1,1,1,1,2,2,2,1,1,2,2,2,1,1,2,2,2,1,1,1,1,1,1), ncol = 5) for (i in 1:5) scene = render.sprite(scene, box, x=2*i, y=2*i, layer=6-i) #> Error in render.sprite(scene, box, x = 2 * i, y = 2 * i, layer = 6 - i): could not find function \"render.sprite\" render.scene(scene) #> Error in render.scene(scene): could not find function \"render.scene\"  #inversion layer bigbox = matrix(1,11,11) scene = render.sprite(scene, bigbox, x=1, y=1, layer='invert') #> Error in render.sprite(scene, bigbox, x = 1, y = 1, layer = \"invert\"): could not find function \"render.sprite\" render.scene(scene) #> Error in render.scene(scene): could not find function \"render.scene\""},{"path":"https://gbkorr.github.io/rcade/reference/render.sprite.html","id":null,"dir":"Reference","previous_headings":"","what":"Render a Sprite to the Scene — render.sprite","title":"Render a Sprite to the Scene — render.sprite","text":"Overlays sprite onto desired layer scene using render.overlay().","code":""},{"path":"https://gbkorr.github.io/rcade/reference/render.sprite.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Render a Sprite to the Scene — render.sprite","text":"","code":"render.sprite(scene, sprite, x, y, layer = 1, palette = NULL)"},{"path":"https://gbkorr.github.io/rcade/reference/render.sprite.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Render a Sprite to the Scene — render.sprite","text":"scene Scene object. sprite Matrix nonnegative integers corresponding pixels small image; see render.matrix(). x X coordinate sprite drawn scene. Specifically, determines position top-left pixel sprite. y Y coordinate purpose. layer Layer sprite drawn. Higher layers drawn top. palette Vector swap colors (numbers) sprite around, e.g. c(0,2,1) swaps values 2 1. Index starts 0. Defaults swapping.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/render.sprite.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Render a Sprite to the Scene — render.sprite","text":"Returns scene object sprite drawn.","code":""},{"path":[]},{"path":"https://gbkorr.github.io/rcade/reference/render.test_animation.html","id":null,"dir":"Reference","previous_headings":"","what":"Test an Animated Sprite — render.test_animation","title":"Test an Animated Sprite — render.test_animation","text":"Plays sprite's animation console. ^C stop.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/render.test_animation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test an Animated Sprite — render.test_animation","text":"","code":"render.test_animation(spritename, sprites)"},{"path":"https://gbkorr.github.io/rcade/reference/render.test_animation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test an Animated Sprite — render.test_animation","text":"spritename Name sprite sprites sprites List sprites, e.g. ROM$sprites.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/render.test_animation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Test an Animated Sprite — render.test_animation","text":"function intended aid sprite creation process. handles sprite$next_animation properly, can used test multi-stage animations . todo: examples mario runcycle","code":""},{"path":"https://gbkorr.github.io/rcade/reference/render.test_font.html","id":null,"dir":"Reference","previous_headings":"","what":"Test a Font — render.test_font","title":"Test a Font — render.test_font","text":"Prints large sampler text using font see looks different contexts. may zoom cmd - see text render properly. Alternatively, can test fonts something like render.matrix(render.text('example_text', font_to_test)).","code":""},{"path":"https://gbkorr.github.io/rcade/reference/render.test_font.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test a Font — render.test_font","text":"","code":"render.test_font(font, verbose = FALSE)"},{"path":"https://gbkorr.github.io/rcade/reference/render.test_font.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test a Font — render.test_font","text":"font Font test. verbose Boolean; print extra text samples?","code":""},{"path":"https://gbkorr.github.io/rcade/reference/render.test_font.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Test a Font — render.test_font","text":"Uses render.text() print following: lowercase pangram uppercase pangram code sample symbols numbers lowercase alphabet uppercase alphabet alphabets drawn last show closest bottom console. things printed useful different purposes. font support characters, samples containing omitted. (e.g. uppercase-fonts skip lowercase samples). include picture render.test_font(fonts.3x5)","code":""},{"path":"https://gbkorr.github.io/rcade/reference/render.test_font.html","id":"verbose","dir":"Reference","previous_headings":"","what":"Verbose","title":"Test a Font — render.test_font","text":"Use verbose = TRUE print samplers: mixed case phrase mixed cases symbols","code":""},{"path":"https://gbkorr.github.io/rcade/reference/render.test_font.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test a Font — render.test_font","text":"","code":"render.test_font(fonts.3x5) #> Error in render.test_font(fonts.3x5): could not find function \"render.test_font\""},{"path":"https://gbkorr.github.io/rcade/reference/render.text.html","id":null,"dir":"Reference","previous_headings":"","what":"Render Text as Sprite — render.text","title":"Render Text as Sprite — render.text","text":"Generates sprite block text, suitable drawing render.matrix.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/render.text.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Render Text as Sprite — render.text","text":"","code":"render.text(   str,   font = rcade::fonts.3x3,   wrap = FALSE,   kerning = NULL,   linespacing = NULL,   alignment = \"left\" )"},{"path":"https://gbkorr.github.io/rcade/reference/render.text.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Render Text as Sprite — render.text","text":"str String make sprite . font Font render text . wrap Pixels space alotted given line text newline automatically created. NULL: text wrapping. kerning Pixels characters horizontally. Otherwise font's default $kerning used. linespacing Pixels characters vertically. Otherwise font's default $linespacing used. alignment 'left', 'center', 'right' text alignment.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/render.text.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Render Text as Sprite — render.text","text":"Returns sprite matrix text.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/render.text.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Render Text as Sprite — render.text","text":"Characters missing font replaced blank spaces. font supports uppercase lowercase, characters coerced supported case.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/render.text.html","id":"limitations","dir":"Reference","previous_headings":"","what":"Limitations","title":"Render Text as Sprite — render.text","text":"function somewhat messily implemented, job. rewrite appropriate someday. function currently supports wrapping whole words; individual words split exceed wrap length. Wrapping also work strings manually newline (.e. \\n).","code":""},{"path":"https://gbkorr.github.io/rcade/reference/render.text.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Render Text as Sprite — render.text","text":"","code":"sprite = render.text('Hello World.', fonts.3x5) #> Error in render.text(\"Hello World.\", fonts.3x5): could not find function \"render.text\" render.matrix(sprite) #> Error in render.matrix(sprite): could not find function \"render.matrix\"  #alignment and wrapping render.matrix(render.text(   'this text is aligned to the right',   wrap = 32,   alignment = 'right' )) #> Error in render.matrix(render.text(\"this text is aligned to the right\",     wrap = 32, alignment = \"right\")): could not find function \"render.matrix\"  #kerning and linespacing render.matrix(render.text(   'very spaced text',   kerning = 3 )) #> Error in render.matrix(render.text(\"very spaced text\", kerning = 3)): could not find function \"render.matrix\"  #newlines with '\\n' render.matrix(render.text(   'Newlines:\\nAre supported.' )) #> Error in render.matrix(render.text(\"Newlines:\\nAre supported.\")): could not find function \"render.matrix\""},{"path":"https://gbkorr.github.io/rcade/reference/rom.help.html","id":null,"dir":"Reference","previous_headings":"","what":"Common Issues — rom.help","title":"Common Issues — rom.help","text":"Unexpected crash? documentation provides debugging resources lists common problems might encounter. Snake vignette goes basic development process useful; can view vignette(\"Snake\").","code":""},{"path":"https://gbkorr.github.io/rcade/reference/rom.help.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Common Issues — rom.help","text":"","code":"rom.help()  ram.help()"},{"path":"https://gbkorr.github.io/rcade/reference/rom.help.html","id":"traceback","dir":"Reference","previous_headings":"","what":"Traceback","title":"Common Issues — rom.help","text":"game crashes, prints traceback, call, error: ?ram.run function tree may useful understanding error occurred; traceback list branches encompassing error call.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/rom.help.html","id":"logging","dir":"Reference","previous_headings":"","what":"Logging","title":"Common Issues — rom.help","text":"Multiple options exist printing information via game code. contents RAM$echo printed game render every frame. base::print() calls visible game crashes due console wiped. global variable foo <<- [debug info] can modified via game code. Thus print() ideal debugging source crash, prints information current tick. RAM$echo useful monitoring values running game, using global variable gives control option record info every tick.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/rom.help.html","id":"timing","dir":"Reference","previous_headings":"","what":"Timing","title":"Common Issues — rom.help","text":"RAM$debug records lot timing-related data relevant timing rollback systems (vignette(\"timing\") vignette(\"rollback\")).","code":""},{"path":"https://gbkorr.github.io/rcade/reference/rom.help.html","id":"empty-lists","dir":"Reference","previous_headings":"","what":"Empty Lists","title":"Common Issues — rom.help","text":"Make sure accidentally wiped RAM RAM$objects. can happen define custom function like ROM$my_function(RAM) forget return RAM end .","code":""},{"path":"https://gbkorr.github.io/rcade/reference/rom.help.html","id":"inputs","dir":"Reference","previous_headings":"","what":"Inputs","title":"Common Issues — rom.help","text":"Make sure tools::R_user_dir(\"rcade\") exists. Double-check ROM$keybinds make sure RAM$actions properly referenced code. Consider adding RAM$echo = RAM$actions ROM$custom show state action every tick.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/rom.help.html","id":"iterating","dir":"Reference","previous_headings":"","what":"Iterating","title":"Common Issues — rom.help","text":"iterate RAM$objects, use syntax   required due R handles nested lists; formatfor (obj RAM$objects) work.","code":"for (i in 1:length(RAM$objects)){     obj = RAM$objects[[i]]  }"},{"path":"https://gbkorr.github.io/rcade/reference/rom.init.html","id":null,"dir":"Reference","previous_headings":"","what":"Create ROM Object — rom.init","title":"Create ROM Object — rom.init","text":"ROM object contains static data running game. ROM elements can set function fact, e.g. ROM$framerate = 30. See `vignette(\"engine\") info.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/rom.init.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create ROM Object — rom.init","text":"","code":"rom.init(   screen.width,   screen.height,   keybinds = c(w = \"up\", a = \"left\", s = \"down\", d = \"right\"),   startup = function(RAM) {      return(RAM)  },   custom = function(RAM) {      return(RAM)  },   sprites = list(),   palette = c(\"  \", \"[]\", \"  \"),   framerate = 60,   backup_duration = 2,   input_delay = 1/60 )"},{"path":"https://gbkorr.github.io/rcade/reference/rom.init.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create ROM Object — rom.init","text":"screen.width Width game screen pixels; see render.scene. screen.height Height game screen pixels. keybinds Vector keys corresponding action; see inputs.process(). startup Function run game initialized ram.init(). Must return RAM. custom Function run game every frame ram.tick(). Must return RAM. sprites List sprites (matrices) used game; see render.animate. palette Vector value 0, 1, 2, 3, etc. sprite drawn render.matrix(). framerate Frames per second game run . 60 recommended, 30 may useful render.ram() takes significant amount time. backup_duration frequently RAM backs seconds; see ram.rollback. need changed default. input_delay Seconds add timestamp every input. Makes inputs get processed slightly sent, reduce frequency rollbacks.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/rom.init.html","id":"game-code","dir":"Reference","previous_headings":"","what":"Game Code","title":"Create ROM Object — rom.init","text":"ROM$custom updates RAM every frame ram.tick(). game code either ROM$custom helper functions stored ROM, demonstrated .","code":""},{"path":"https://gbkorr.github.io/rcade/reference/rom.init.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create ROM Object — rom.init","text":"","code":"testrom = rom.init(64,16) #> Error in rom.init(64, 16): could not find function \"rom.init\" testrom$example_function = function(){print('foo')} #> Error: object 'testrom' not found testrom$startup = function(RAM){RAM$ROM$example_function(); return(RAM)} #> Error: object 'testrom' not found RAM = ram.init(testrom) #> Error in ram.init(testrom): could not find function \"ram.init\""},{"path":"https://gbkorr.github.io/rcade/reference/time.ram.html","id":null,"dir":"Reference","previous_headings":"","what":"Temporal RAM Position — time.ram","title":"Temporal RAM Position — time.ram","text":"Returns far, seconds, RAM 'ahead' System time. Used convenience ram.update(). See vignette(\"timing\") info; x-axis diagrams time.ram().","code":""},{"path":"https://gbkorr.github.io/rcade/reference/time.ram.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Temporal RAM Position — time.ram","text":"","code":"# S3 method for class 'ram' time(RAM)"},{"path":"https://gbkorr.github.io/rcade/reference/time.ram.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Temporal RAM Position — time.ram","text":"RAM RAM object.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/time.ram.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Temporal RAM Position — time.ram","text":"= RAM$time - time.sec()","code":""},{"path":"https://gbkorr.github.io/rcade/reference/time.sec.html","id":null,"dir":"Reference","previous_headings":"","what":"Get System Time as a Float — time.sec","title":"Get System Time as a Float — time.sec","text":"Grabs absolute system time value base::Sys.time(). used package accurately time frames across instances computers.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/time.sec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get System Time as a Float — time.sec","text":"","code":"# S3 method for class 'sec' time()"},{"path":"https://gbkorr.github.io/rcade/reference/time.sec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get System Time as a Float — time.sec","text":"double representing seconds since 1970 sub-millisecond precision.","code":""},{"path":"https://gbkorr.github.io/rcade/reference/time.sec.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get System Time as a Float — time.sec","text":"= .double(Sys.time())","code":""},{"path":"https://gbkorr.github.io/rcade/reference/time.sec.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get System Time as a Float — time.sec","text":"","code":"print(time.sec(),digits=20) #> Error in time.sec(): could not find function \"time.sec\""}]
